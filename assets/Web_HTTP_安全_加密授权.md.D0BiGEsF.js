import{_ as o,c as s,o as t,a1 as n}from"./chunks/framework.yskgK-vV.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/HTTP/安全/加密授权.md","filePath":"Web/HTTP/安全/加密授权.md"}'),r={name:"Web/HTTP/安全/加密授权.md"},e=n('<h2 id="加密" tabindex="-1">加密 <a class="header-anchor" href="#加密" aria-label="Permalink to &quot;加密&quot;">​</a></h2><ul><li><p>因数、质数、余数</p></li><li><p>公钥和私钥</p><ul><li>公钥：<code>（E，N）</code>，明文 E%N = 密文</li><li>私钥：<code>（D，N）</code>，密文 D%N = 明文</li></ul><blockquote><ol><li>两个质数：<code>p = 3</code>；<code>q = 11</code></li><li>质数相乘：<code>N = p * q = 33</code></li><li>欧拉函数：<code>T = (p - 1) * (q - 1) = 20</code></li><li>选公钥 E：质数；<code>1 &lt; 公钥 &lt; T</code>；不是 T 的因子；<code>E = （3， 33）</code></li><li>算私钥 D：<code>（D * E）% T = 1</code>;<code>D = (7, 33)</code></li></ol></blockquote></li></ul><hr><h2 id="授权问题" tabindex="-1">授权问题 <a class="header-anchor" href="#授权问题" aria-label="Permalink to &quot;授权问题&quot;">​</a></h2><h3 id="_01-什么是认证" tabindex="-1">01. 什么是认证？ <a class="header-anchor" href="#_01-什么是认证" aria-label="Permalink to &quot;01. 什么是认证？&quot;">​</a></h3><ul><li>验证当前用户的身份，证明<strong>你是你自己</strong></li><li>互联网中的认证： <ul><li>用户名、密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li></ul></li></ul><h3 id="_02-什么是授权" tabindex="-1">02. 什么是授权？ <a class="header-anchor" href="#_02-什么是授权" aria-label="Permalink to &quot;02. 什么是授权？&quot;">​</a></h3><ul><li>用户授予<strong>第三方</strong>应用访问用户的某些资源的<strong>权限</strong></li><li>授权的方式： <ul><li><strong>Cookie</strong></li><li><strong>Session</strong></li><li><strong>Token</strong></li><li><strong>OAuth</strong></li></ul></li></ul><h3 id="_03-什么是凭证" tabindex="-1">03. 什么是凭证？ <a class="header-anchor" href="#_03-什么是凭证" aria-label="Permalink to &quot;03. 什么是凭证？&quot;">​</a></h3><ul><li>实现认证和授权的前提是，需要<strong>一种媒介（证书）</strong>，来标记访问者的<strong>身份</strong></li></ul><h3 id="_04-什么是-cookie" tabindex="-1">04. 什么是 Cookie？ <a class="header-anchor" href="#_04-什么是-cookie" aria-label="Permalink to &quot;04. 什么是 Cookie？&quot;">​</a></h3><ul><li><p>HTTP 是无状态的协议</p><ul><li>即，对事务处理<strong>没有记忆能力</strong>，每次客户端和服务端会话完成时，服务端<strong>不会保存任何会话信息</strong></li><li>这样，每次请求都会是完全独立的，服务端也就<strong>无法确认和分辨</strong>当前访问者的身份信息</li><li>所以，为了进行会话跟踪，就必须要主动的去<strong>维护一个状态</strong>，这个状态用于告诉服务端当前访问者的<strong>身份信息</strong></li><li>这种状态就是通过<strong>Cookie</strong>，或者<strong>Session</strong>去实现的</li></ul></li><li><p><strong>Cookie</strong>是存储在客户端的：</p><ul><li><strong>Cookie</strong>是服务器通过<code>Set-Cookie</code>发送到客户端，并由客户端存储在本地的一小块数据</li><li>并且，它会在下次请求时，被设置在<code>Cookie</code>字段里</li></ul></li><li><p><strong>Cookie</strong>是不可跨域的：</p><ul><li>每个<code>Cookie</code>都会绑定单一的域名，是无法在其它域名下获取使用的</li><li>一级域名和二级域名之间是允许共享使用的，通过<strong>domain</strong></li></ul></li><li><p><strong>Cookie</strong>的属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，用于设置<strong>Cookie</strong>的名称，和对应的值，都是字符串类型</td></tr><tr><td><strong>domain</strong></td><td>指定<strong>Cookie</strong>的所属域名，默认为当前域名</td></tr><tr><td><strong>path</strong></td><td>指定<strong>Cookie</strong>在哪一个路径（路由）下生效，默认为<code>/</code></td></tr><tr><td><strong>maxAge</strong></td><td><strong>Cookie</strong>的失效时间，单位为秒。正数：表示<code>maxAge</code>秒后失效；负数：临时<code>cookie</code>，关闭浏览器即失效；<strong>0</strong>：删除该<code>cookie</code>。默认值为**-1**</td></tr><tr><td><strong>expires</strong></td><td>设置过期日期，在这个日期之后的时间<strong>Cookie</strong>失效</td></tr><tr><td><strong>secure</strong></td><td>是否使用安全协议传输。安全协议有<code>HTTPS</code>、<code>SSL</code>等。默认为<code>false</code></td></tr><tr><td><strong>httpOnly</strong></td><td>设置该属性可防止通过 JS 脚本读取<strong>Cookie</strong>信息</td></tr></tbody></table></li></ul><h3 id="_05-什么是-session" tabindex="-1">05. 什么是 Session？ <a class="header-anchor" href="#_05-什么是-session" aria-label="Permalink to &quot;05. 什么是 Session？&quot;">​</a></h3><ul><li><p>基本概念</p><ul><li><strong>Session</strong>是另一种<strong>记录服务器和客户端会话状态</strong>的机制</li><li><strong>Session</strong>是基于<strong>Cookie</strong>实现的，<strong>Session</strong>存储在服务器端，<strong>sessionId</strong>会被存储到客户端的<strong>Cookie</strong>中</li></ul></li><li><p><strong>Session</strong>的认证流程：</p><ul><li>用户第一次请求服务器的时候，服务器会根据用户提交的相关信息，创建对应的<strong>Session</strong></li><li>在返回请求时，会将该<strong>Session</strong>的唯一标识信息<strong>Session ID</strong>，返回给浏览器</li><li>浏览器接收到<strong>Session ID</strong>后，会将此信息存入到<strong>Cookie</strong>中，并在<strong>Cookie</strong>中记录所属域名</li><li>在下次请求时，会判断当前域名下是否存在<strong>Cookie</strong>信息，如果存在，就会将<strong>Cookie</strong>信息一起发送给服务端</li><li>服务端会从<strong>Cookie</strong>中获取<strong>Session Id</strong>，再根据<strong>Session Id</strong>去查找对应的<strong>Session</strong>信息</li><li>如果没有找到，则表示没有登录，或者登录失效；如果找到了，则表示已经登录，可继续执行后面操作</li></ul><blockquote><p><strong>Session ID</strong>是连接<strong>Cookie</strong>和<strong>Session</strong>的一道桥梁</p></blockquote></li></ul><h3 id="_06-cookie-和-session-的区别" tabindex="-1">06. Cookie 和 Session 的区别？ <a class="header-anchor" href="#_06-cookie-和-session-的区别" aria-label="Permalink to &quot;06. Cookie 和 Session 的区别？&quot;">​</a></h3><ul><li><p>安全性：<strong>Session</strong>比<strong>Cookie</strong>安全。<strong>Session</strong>存储在服务器端，<strong>Cookie</strong>存储在客户端</p></li><li><p>存取值的类型不同：<strong>Cookie</strong>只支持字符串数据，<strong>Session</strong>支持任意数据类型</p></li><li><p>有效期不同：<strong>Cookie</strong>可设置长时间保持，<strong>Session</strong>的失效时间较短，客户端关闭或者<strong>Session</strong>超时都会失效、</p></li><li><p>存储大小不同：<strong>Cookie</strong>的数据一般不同超过<strong>4k</strong>，<strong>Session</strong>可存储数据原告于<strong>Cookie</strong></p></li></ul><h3 id="_07-什么是-token" tabindex="-1">07. 什么是 Token? <a class="header-anchor" href="#_07-什么是-token" aria-label="Permalink to &quot;07. 什么是 Token?&quot;">​</a></h3><h4 id="_1-access-token" tabindex="-1">（1）<strong>Access Token</strong> <a class="header-anchor" href="#_1-access-token" aria-label="Permalink to &quot;（1）**Access Token**&quot;">​</a></h4><ul><li><p>表示访问资源接口（API）时，所需要的资源凭证</p></li><li><p>简单<strong>Token</strong>的组成：</p><ul><li><strong>uid</strong>：用户唯一的身份标识</li><li><strong>time</strong>：当前时间的时间戳</li><li><strong>sign</strong>：签名</li></ul></li><li><p>特点：</p><ul><li>服务端无状态化，可扩展性好</li><li>支持移动端设备</li><li>安全</li><li>支持跨程序调用</li></ul></li><li><p><strong>Token</strong>的身份验证流程：</p><ul><li>客户端使用<em>用户名和密码</em>请求登录，服务端收到请求后，会验证<em>用户名和密码</em></li><li>验证成功后，服务端会签发一个<strong>Token</strong>，并把这个<strong>Token</strong>返回给客户端</li><li>客户端收到<strong>Token</strong>后，会将其存储起来，放入<strong>Cookie</strong>中，或者<strong>Storage</strong>中</li><li>客户端后面的每次请求都会携带这个<strong>Token</strong></li><li>服务端收到请求后，会去验证<strong>Token</strong>，验证成功后，才返回请求的数据</li></ul><blockquote><p>其它：</p><ul><li>每次请求都需要携带<strong>Token</strong>，需要把<strong>Token</strong>放到<strong>HTTP</strong>的<strong>Header</strong>里</li><li>基于<strong>Token</strong>的用户认证是一种服务端无状态的认证方式，服务端不用存放<strong>Token</strong>数据</li><li><strong>Token</strong>完全由应用管理，所以它可以避开同源策略</li></ul></blockquote></li></ul><h4 id="_2-refresh-token" tabindex="-1">（2）<strong>Refresh Token</strong> <a class="header-anchor" href="#_2-refresh-token" aria-label="Permalink to &quot;（2）**Refresh Token**&quot;">​</a></h4><ul><li><p>这是另一种<strong>Token</strong>，用于刷新<strong>Access Token</strong></p><ul><li>如果没有<strong>Refresh Token</strong>也可以刷新<strong>Access Token</strong>，只是每次都需要用户重新输入<em>用户名和密码</em></li><li>有了这个<strong>Refresh Token</strong>，客户端可以直接用这个去更新<strong>Access Token</strong></li></ul></li><li><p>验证流程：</p><ul><li>在服务端验证成功后，会返回两种<strong>Token</strong>给客户端 <ul><li><strong>Access Token</strong>用于正常的身份验证，过期时间较短</li><li><strong>Refresh Token</strong>用于刷新<strong>Access Token</strong>，过期时间较长</li></ul></li><li>如果<strong>Access Token</strong>过期了，但<strong>Refresh Token</strong>没有过期，服务端就会返回一个新的<strong>Access Token</strong>给客户端</li><li>如果<strong>Refresh Token</strong>也过期了，用户需要重新输入登录</li></ul><blockquote><p>其它：</p><ul><li><strong>Refresh Token</strong>及其过期时间，是存储在服务器的数据库中的</li><li>只有在申请新的<strong>Access Token</strong>时，才回去验证这个<strong>Refresh Token</strong>是否过期</li></ul></blockquote></li></ul><h3 id="_08-token-和-session-的区别" tabindex="-1">08. Token 和 Session 的区别？ <a class="header-anchor" href="#_08-token-和-session-的区别" aria-label="Permalink to &quot;08. Token 和 Session 的区别？&quot;">​</a></h3><ul><li><p><strong>Session</strong>是一种，记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</p></li><li><p><strong>Token</strong>是令牌，是一种访问资源接口（API）时所需要的资源凭证，使服务端无状态化，不会存储会话信息</p></li><li><p><strong>Token</strong>的安全性比<strong>Session</strong>好，两者并不矛盾，可同时使用</p></li></ul><h3 id="_09-什么是-jwt" tabindex="-1">09. 什么是 JWT？ <a class="header-anchor" href="#_09-什么是-jwt" aria-label="Permalink to &quot;09. 什么是 JWT？&quot;">​</a></h3><ul><li><p><strong>JWT</strong>，即<code>JSON Web Token</code>，是目前最流行的<strong>跨域认证</strong>解决方案，是一种<strong>认证授权机制</strong></p></li><li><p>用于在身份提供者和服务提供者之间传递被认证的用户身份信息，然后从资源服务器获取资源</p></li><li><p><strong>JWT</strong>认证流程：</p><ul><li><p>用户输入<em>用户名和密码</em>登录，服务端认证成功后，会返回客户端一个<strong>JWT</strong></p></li><li><p>客户端将<strong>Token</strong>存到本地，可以使用<strong>Cookie</strong>或者<strong>Storage</strong></p></li><li><p>当用户希望访问一个受保护的路由、资源时，需要在请求头的<code>Authorization</code>字段中使用<code>Bearer</code>模式，来添加<strong>JWT</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Authorization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: bearer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>服务端会检查请求头的<code>Authorization</code>中的<strong>JWT</strong>信息，如果合法，则允许用户的行为</p></li></ul></li></ul><h3 id="_10-token-和-jwt-的区别" tabindex="-1">10. Token 和 JWT 的区别? <a class="header-anchor" href="#_10-token-和-jwt-的区别" aria-label="Permalink to &quot;10. Token 和 JWT 的区别?&quot;">​</a></h3><ul><li><p>相同：</p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul></li><li><p>区别：</p><ul><li><strong>Token</strong>：服务端在验证客户端发送的<strong>Token</strong>时，还需要查询数据库以获取用户信息，然后验证<strong>Token</strong>是否有效</li><li><strong>JWT</strong>：将<strong>Token</strong>和<strong>Payload</strong>加密后存储在客户端，服务端只需要使用密钥解密进行校验即可，不需要查询数据库</li></ul></li></ul><h3 id="_11-常见的前后端鉴权方式" tabindex="-1">11. 常见的前后端鉴权方式 <a class="header-anchor" href="#_11-常见的前后端鉴权方式" aria-label="Permalink to &quot;11. 常见的前后端鉴权方式&quot;">​</a></h3><ul><li><strong>Session-Cookie</strong></li><li><strong>Token</strong>验证，包括<strong>JWT</strong>、<strong>SSO</strong></li><li><strong>OAuth2.0</strong>,开发授权</li></ul><h2 id="其它常见问题" tabindex="-1">其它常见问题 <a class="header-anchor" href="#其它常见问题" aria-label="Permalink to &quot;其它常见问题&quot;">​</a></h2><h3 id="_01-cookie问题" tabindex="-1">01. <strong>Cookie</strong>问题 <a class="header-anchor" href="#_01-cookie问题" aria-label="Permalink to &quot;01. **Cookie**问题&quot;">​</a></h3><ul><li><strong>Cookie</strong>存储在客户端，容易被客户端篡改，使用前需要验证其合法性</li><li>不要存储敏感数据，如密码、余额等</li><li>使用<strong>httpOnly</strong>可一定程度上提高安全性</li><li>存储的数据不能超过<strong>4k</strong></li><li>设置正确的<strong>domain</strong>和<strong>path</strong>可减少数据传输</li><li><strong>Cookie</strong>无法跨域</li><li>一个网站最多存<strong>20</strong>个<strong>Cookie</strong>，一个浏览器一般只允许存放<strong>300</strong>个<strong>Cookie</strong></li><li>移动端对<strong>Cookie</strong>的支持不是很好</li></ul><h3 id="_02-session问题" tabindex="-1">02. <strong>Session</strong>问题 <a class="header-anchor" href="#_02-session问题" aria-label="Permalink to &quot;02. **Session**问题&quot;">​</a></h3><ul><li><strong>Session</strong>存储在服务端，可能会占用较多内存</li><li>多台服务器之间的<strong>Session</strong>共享问题，请求的服务器不一定是创建<strong>Session</strong>的服务器</li><li>跨域问题</li><li><strong>Session Id</strong>存储在<strong>Cookie</strong>中，如果浏览器禁止<strong>Cookie</strong>，可把<strong>Session Id</strong>拼写在<strong>URL</strong>后面</li><li>移动端支持不是很好</li></ul><h3 id="_03-token问题" tabindex="-1">03. <strong>Token</strong>问题 <a class="header-anchor" href="#_03-token问题" aria-label="Permalink to &quot;03. **Token**问题&quot;">​</a></h3><ul><li><strong>Token</strong>完全由应用管理，所以它可以避开同源策略</li><li><strong>Token</strong>可以避免 CSRF 攻击，因为不需要<strong>Cookie</strong>了</li><li>移动端常用<strong>Token</strong></li></ul><h3 id="_04-sessionstorage在同一网站多个标签页内共享数据吗" tabindex="-1">04. <code>sessionStorage</code>在同一网站多个标签页内共享数据吗？ <a class="header-anchor" href="#_04-sessionstorage在同一网站多个标签页内共享数据吗" aria-label="Permalink to &quot;04. `sessionStorage`在同一网站多个标签页内共享数据吗？&quot;">​</a></h3><ul><li>这取决于<strong>标签页如何打开</strong><ul><li>通过点击链接跳转打开的新标签页，他们之间可以共享<code>Sessin</code></li><li>但是新开一个标签页，再打开链接，它们之间不共享同一个<code>Session</code>，新开标签页会重新初始化一个<code>session</code></li></ul></li></ul>',38),i=[e];function l(g,a,d,k,c,h){return t(),s("div",null,i)}const T=o(r,[["render",l]]);export{p as __pageData,T as default};
