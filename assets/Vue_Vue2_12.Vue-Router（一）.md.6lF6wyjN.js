import{_ as t,c as e,o,a1 as l}from"./chunks/framework.yskgK-vV.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Vue/Vue2/12.Vue-Router（一）.md","filePath":"Vue/Vue2/12.Vue-Router（一）.md"}'),s={name:"Vue/Vue2/12.Vue-Router（一）.md"},i=l('<h2 id="vue-router" tabindex="-1"><code>Vue-Router</code> <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;`Vue-Router`&quot;">​</a></h2><h3 id="_01-基本概念" tabindex="-1">01. 基本概念 <a class="header-anchor" href="#_01-基本概念" aria-label="Permalink to &quot;01. 基本概念&quot;">​</a></h3><h4 id="_1-基础概念" tabindex="-1">（1）基础概念 <a class="header-anchor" href="#_1-基础概念" aria-label="Permalink to &quot;（1）基础概念&quot;">​</a></h4><ul><li><code>Vue-router</code>：即 SPA（单页应用）的路径管理器，</li><li>根据不同的用户 URL 请求，返回不同的内容</li><li><code>vue-router</code>是 Vue 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用 <ul><li><code>vue</code>的单页面应用是基于路由和组件的 <ul><li>路由用于设定访问路径，并<strong>将路径和组件映射</strong></li></ul></li></ul></li></ul><h4 id="_2-对比" tabindex="-1">（2）对比 <a class="header-anchor" href="#_2-对比" aria-label="Permalink to &quot;（2）对比&quot;">​</a></h4><ul><li>传统页面应用，是用一些<strong>超链接</strong>来实现页面切换和跳转的</li><li>单页面应用中，则是<strong>路径之间的切换，也就是组件的切换</strong></li></ul><h4 id="_3-本质" tabindex="-1">（3）本质 <a class="header-anchor" href="#_3-本质" aria-label="Permalink to &quot;（3）本质&quot;">​</a></h4><ul><li>路由模块的本质：就是<strong>建立起<code>url</code>和组件之间的一一映射关系</strong></li></ul><h3 id="_02-实现原理" tabindex="-1">02. 实现原理 <a class="header-anchor" href="#_02-实现原理" aria-label="Permalink to &quot;02. 实现原理&quot;">​</a></h3><h4 id="_1-原理" tabindex="-1">（1）原理 <a class="header-anchor" href="#_1-原理" aria-label="Permalink to &quot;（1）原理&quot;">​</a></h4><ul><li><p><code>SPA(single page application)</code>：单一页面应用程序，只有一个完整的页面</p><ul><li>它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容</li><li>单页面应用的核心之一是：更新视图而不重新请求页面</li></ul></li><li><p><code>vue-router</code>在实现单页面前端路由时，提供了两种方式：</p><ul><li><strong>Hash 模式</strong>和<strong>History 模式</strong></li></ul><blockquote><p>根据<code>mode</code>参数来决定采用哪一种方式</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果这里不写,路由默认为 hash模式</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      routes: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote></li></ul><h3 id="_03-两种模式" tabindex="-1">03. 两种模式 <a class="header-anchor" href="#_03-两种模式" aria-label="Permalink to &quot;03. 两种模式&quot;">​</a></h3><h4 id="_1-hash-模式" tabindex="-1">（1）Hash 模式 <a class="header-anchor" href="#_1-hash-模式" aria-label="Permalink to &quot;（1）Hash 模式&quot;">​</a></h4><ul><li><p>模式配置：<code>vue-router</code> 默认 <strong>hash 模式</strong></p></li><li><p>实现原理：</p><ul><li>使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载</li><li><code>onhashchange</code> 事件：通过这个事件来监测 hash 值的变化，从而更新页面的部分内容</li></ul></li><li><p>工作方式：</p><ul><li><code>hash</code> 即 URL 中的<code>#</code>符号，也称为锚点，代表的是网页中的一个位置</li><li><code>hash</code> 的改变，即改变<code>#</code>后的部分，浏览器只会<strong>滚动到相应位置</strong>，不会重新加载网页 <ul><li>同时，每一次改变<code>#</code>后的部分，都会在浏览器的<strong>访问历史中</strong>增加一个记录</li><li>使用浏览器的【后退】按钮，就可以回到上一个位置</li></ul></li><li><code>hash</code> 出现在 URL 中，但<strong>不会被包含在 Http 请求中</strong>，仅有<code>#</code>符号之前的内容会被包含在请求中 <ul><li>因此，对后端来说，即使没有做到对路由全覆盖，也不会返回 404 错误，且改变 hash 不会重新加载页面</li></ul></li></ul></li><li><p>最后总结：</p><ul><li>Hash 模式就是通过<strong>锚点值的改变</strong>，根据不同的值，渲染指定 DOM 位置的不同数据</li></ul></li></ul><h4 id="_2-history-模式" tabindex="-1">（2）History 模式 <a class="header-anchor" href="#_2-history-模式" aria-label="Permalink to &quot;（2）History 模式&quot;">​</a></h4><blockquote><ul><li><p>由于 hash 模式会在 URL 地址中自带<code>#</code>，这样 URL 地址看上去就不是那么美观</p></li><li><p>如果不想要很丑的 hash <code>#</code>符号，我们可以使用 history 模式</p></li></ul></blockquote><ul><li><p>模式配置：只需要在配置路由规则时，加入<code>mode: &#39;history&#39;</code></p></li><li><p>实现原理：</p><ul><li>利用了 HTML5 中新增的两个 API—— <code>pushState()</code>、 <code>replaceState()</code></li><li>这两个方法应用于浏览器记录栈，在当前已有的 <code>back</code>、<code>forward</code>、<code>go</code> 基础之上，它们提供了对历史记录修改的功能</li><li>通过这两个 API ，可以改变 URL 地址且不会发送请求，不需要重新加载页面</li></ul></li><li><p>工作方式：</p><ul><li>当你使用 history 模式时，URL 正常显示，例如 <a href="http://xxx.com/user/id%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%A4%9A%E4%BD%99%E7%9A%84%60#%60%E7%AC%A6%E5%8F%B7" target="_blank" rel="noreferrer">http://xxx.com/user/id，没有多余的`#`符号</a></li><li>但因为没有 <code># </code>号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求 <ul><li>这个实现需要服务器的支持</li></ul></li><li>而且由于在发送请求时，前端的 URL 必须和实际请求 URL 一致，否则将返回 404 错误 <ul><li>因此， 在 URL 匹配不到任何静态资源时，应该返回同一个页面（如首页）</li></ul></li></ul></li><li><p>最后总结：</p><ul><li>History 模式就是通过<code>pushState()</code>方法来对浏览器的浏览记录进行修改，来达到不用请求后端来渲染的效果</li></ul></li></ul><h4 id="_3-比较" tabindex="-1">（3）比较 <a class="header-anchor" href="#_3-比较" aria-label="Permalink to &quot;（3）比较&quot;">​</a></h4><ul><li><p><strong>History 模式</strong>设置新的 URL 可以是与当前 URL <strong>同源的任意 URL</strong></p></li><li><p><strong>Hash 模式</strong>只可修改 <code>#</code> 后面的部分，因此只能设置与当前 URL <strong>同文档的 URL</strong></p><hr></li><li><p><strong>History 模式</strong>设置的新 URL 可以与当前 URL <strong>一模一样</strong>，这样也会把记录添加到栈中</p></li><li><p><strong>Hash 模式</strong>设置的新值必须与原来<strong>不一样</strong>才会触发操作并将记录添加到栈中</p><hr></li><li><p><strong>History 模式</strong>通过<code>stateObject</code> 参数可以添加<strong>任意类型</strong>的数据到记录中</p></li><li><p><strong>Hash 模式</strong>只能添加<strong>短字符串</strong></p><hr></li><li><p><strong>History 模式</strong>的前端 URL 必须与后端 URL 一致，否则后端无法处理，将<strong>返回 404 错误</strong></p></li><li><p><strong>Hash 模式</strong>即使后端没有路由，也<strong>不会返回 404 错误</strong></p><hr></li><li><p><strong>History 模式</strong>可以设置额外的<code>title</code>属性供后续使用</p></li></ul><table><thead><tr><th style="text-align:left;">History 模式</th><th style="text-align:left;">Hash 模式</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>History 模式</strong>设置新的 URL 可以是与当前 URL <strong>同源的任意 URL</strong></td><td style="text-align:left;"><strong>Hash 模式</strong>只可修改 <code>#</code> 后面的部分，因此只能设置与当前 URL <strong>同文档的 URL</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>设置的新 URL 可以与当前 URL <strong>一模一样</strong>，这样也会把记录添加到栈中</td><td style="text-align:left;"><strong>Hash 模式</strong>设置的新值必须与原来<strong>不一样</strong>才会触发操作并将记录添加到栈中</td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>通过<code>stateObject</code> 参数可以添加<strong>任意类型</strong>的数据到记录中</td><td style="text-align:left;"><strong>Hash 模式</strong>只能添加<strong>短字符串</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>的前端 URL 必须与后端 URL 一致，否则后端无法处理，将<strong>返回 404 错误</strong></td><td style="text-align:left;"><strong>Hash 模式</strong>即使后端没有路由，也<strong>不会返回 404 错误</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>可以设置额外的<code>title</code>属性供后续使用</td><td style="text-align:left;">---</td></tr></tbody></table><blockquote><p>注：还有一种<code>abstract</code>模式，它支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></blockquote><h3 id="_04-页面跳转" tabindex="-1">04. 页面跳转 <a class="header-anchor" href="#_04-页面跳转" aria-label="Permalink to &quot;04. 页面跳转&quot;">​</a></h3><h4 id="_1-修改地址栏" tabindex="-1">（1）修改地址栏 <a class="header-anchor" href="#_1-修改地址栏" aria-label="Permalink to &quot;（1）修改地址栏&quot;">​</a></h4><ul><li>直接修改地址栏进行跳转</li></ul><h4 id="_2-编程式导航" tabindex="-1">（2）编程式导航 <a class="header-anchor" href="#_2-编程式导航" aria-label="Permalink to &quot;（2）编程式导航&quot;">​</a></h4><ul><li><p>通过调用 JavaScript 形式的 API 实现</p><ul><li><p><code>this.$router.push(‘路由地址’)</code></p><blockquote><p>会向<code>history</code>栈添加一个记录，可通过浏览器后退按钮回退</p></blockquote></li><li><p><code>this.$router.replace()</code></p><blockquote><p>会替换掉当前<code>history</code>记录，不会向<code>history</code>添加记录</p></blockquote></li><li><p><code>this.$router.go(n)</code></p><blockquote><p>用<code>n</code>表示在<code>history</code>记录中前进/后退多少步，类似于方法<code>window.history.go(n)</code></p></blockquote></li></ul></li></ul><h4 id="_3-声明式导航" tabindex="-1">（3）声明式导航 <a class="header-anchor" href="#_3-声明式导航" aria-label="Permalink to &quot;（3）声明式导航&quot;">​</a></h4><ul><li>通过点击链接实现： <code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></li></ul>',28),a=[i];function r(n,d,h,c,u,p){return o(),e("div",null,a)}const b=t(s,[["render",r]]);export{k as __pageData,b as default};
