import{_ as o,c as l,o as t,a1 as i}from"./chunks/framework.yskgK-vV.js";const r="/note/assets/eventloop.-48SObWG.png",e="/note/assets/task.4YNa9kHE.png",S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"JS/JavaScript/ECMAScript进阶/03.事件循环.md","filePath":"JS/JavaScript/ECMAScript进阶/03.事件循环.md"}'),s={name:"JS/JavaScript/ECMAScript进阶/03.事件循环.md"},n=i('<h2 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><h3 id="_01-事件循环" tabindex="-1">01. 事件循环 <a class="header-anchor" href="#_01-事件循环" aria-label="Permalink to &quot;01. 事件循环&quot;">​</a></h3><ul><li>事件循环<code>Event Loop</code>，这是目前浏览器和<code>NodeJS</code>处理<code>JavaScript</code>代码的一种机制 <ul><li>而这种机制存在的背后，就是因为<code>JavaScript</code>是一门<strong>单线程</strong>的语言 <ul><li>单线程和多线程最简单的区别就是：单线程同一个时间只能做一件事情，而多线程同一个时间能做多件事情</li></ul></li><li>单线程就意味着，所有任务的执行都需要<strong>排队</strong>，只有前一个任务结束，才能执行下一个任务</li></ul></li><li>这种，由主线程<strong>从任务队列中去读取</strong>事件，在<strong>调用栈上去执行</strong>，并且<strong>不断循环重复</strong>的过程，就是<strong>事件循环</strong><ul><li>是一种用于解决 <code>JavaScript</code> 单线程运行时<strong>不会阻塞的执行机制</strong></li></ul></li></ul><h3 id="_02-调用栈" tabindex="-1">02. 调用栈 <a class="header-anchor" href="#_02-调用栈" aria-label="Permalink to &quot;02. 调用栈&quot;">​</a></h3><blockquote><p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈 所有的任务都会被放到调用栈等待主线程执行</p></blockquote><ul><li>在<code>JavaScript</code>运行的时候，主线程会形成一个<strong>栈</strong><ul><li>这个栈主要是解释器用来最终函数执行流的一种机制</li><li>通常这个栈被称为<strong>调用栈</strong><code>Call Stack</code>，或者<strong>执行栈</strong>（<code>Execution Context Stack</code>），或者<strong>执行上下文栈</strong></li></ul></li><li>调用栈具有<code>LIFO</code>（<strong>后进先出</strong>，<code>Last in First Out</code>）的结构，其存放的是代码执行期间的所有执行上下文 <ul><li>每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行</li><li>正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行</li><li>当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码</li><li>但分配的调用栈空间被占满，会引发<strong>堆栈溢出</strong>的报错</li></ul></li><li>当函数执行的时候，会被添加到<strong>栈的顶部</strong>（<code>push</code>） <ul><li>当执行栈中执行完该函数，就会将其从栈顶移除（<code>pop</code>）</li><li>直到栈内被清空</li></ul></li></ul><h3 id="_03-任务队列" tabindex="-1">03. 任务队列 <a class="header-anchor" href="#_03-任务队列" aria-label="Permalink to &quot;03. 任务队列&quot;">​</a></h3><ul><li>任务队列具有<code>FIFO</code>（<strong>先进先出</strong>，<code>First in First Out</code>）的结构 <ul><li>因此任务队列会按照进入队列的顺序<strong>依次执行</strong></li><li>排在前面的任务，会优先被主线程<code>main thread</code>读取</li></ul></li><li>任务队列会在执行栈被清空后，依次进入主线程 <ul><li>注意任务队列上一些函数触发的条件</li><li>有些事件，如定时器，只有在事件到了之后才会被触发</li></ul></li></ul><h3 id="_04-同步任务和异步任务" tabindex="-1">04. 同步任务和异步任务 <a class="header-anchor" href="#_04-同步任务和异步任务" aria-label="Permalink to &quot;04. 同步任务和异步任务&quot;">​</a></h3><ul><li>这个被读取的任务队列又可以分为两种：<strong>同步任务和异步任务</strong><ul><li>每个任务都是在做两件事情，就是<strong>发起调用</strong>和<strong>得到结果</strong></li></ul></li><li><strong>同步任务</strong>就是： <ul><li>按照代码顺序和调用顺序，进入执行栈中执行的任务</li><li>任务执行结束后就移出调用栈</li><li>同步任务发起调用后，<strong>很快就可以得到结果</strong></li></ul></li><li><strong>异步任务</strong>就是： <ul><li>在某种条件下才会执行的任务</li><li>它依旧会进入调用栈中，然后发起调用，然后解释器会将其<strong>响应回调任务</strong>放入一个<strong>任务队列</strong>，紧接着调用栈会将这个任务移除</li><li>当<strong>主线程清空后</strong>，即所有同步任务结束后，解释器会<strong>读取任务队列</strong>，并<strong>依次</strong>将<strong>已完成的异步任务</strong>加入调用栈中并执行</li><li>异步任务调用后是<strong>无法立即得到结果</strong></li></ul></li></ul><h3 id="_05-宏任务和微任务" tabindex="-1">05. 宏任务和微任务 <a class="header-anchor" href="#_05-宏任务和微任务" aria-label="Permalink to &quot;05. 宏任务和微任务&quot;">​</a></h3><ul><li>在异步任务中，其实还分为<strong>宏任务队列</strong>（<code>Task Queue</code>）和<strong>微任务队列</strong>（<code>Microtask Queue</code>）</li><li>对应的里面存放的就是<strong>宏任务</strong>和<strong>微任务</strong><ul><li>宏任务包括：<code>script</code>的全部代码，<code>setTimeout</code>，<code>setInterval</code>，<code>I/O</code>，UI 渲染</li><li>微任务包括：<code>Promise</code>的回调函数，<code>MutationObserver</code><ul><li><strong>注意</strong>：<code>Promise</code>本身是同步任务，但其回调函数<code>.then()</code>是异步任务中的微任务</li></ul></li></ul></li></ul><h3 id="_06-执行" tabindex="-1">06. 执行 <a class="header-anchor" href="#_06-执行" aria-label="Permalink to &quot;06. 执行&quot;">​</a></h3><ul><li><code>JS</code>开始执行的时候，会把代码分为两类 <ul><li>一种是同步任务，会放入<strong>执行栈</strong>中，等待主线程的执行</li><li>一种是异步任务，会放入<strong>任务队列</strong>中 <ul><li>微任务会放入<strong>微任务队列</strong>中</li><li>宏任务会放入<strong>宏任务队列</strong>中</li></ul></li></ul></li><li>然后，<code>JS</code>开始执行，会先把执行栈中的任务清空，然后会去任务队列中读取一个任务 <ul><li>读取任务时，会<strong>优先读取当前任务队列的微任务</strong></li><li>当微任务队列<strong>清空后</strong>，才会去<strong>读取下一个宏任务</strong></li></ul></li><li>执行下一个宏任务时，又会再次进行分类操作 <ul><li>即，将当次任务执行中遇到的<strong>微任务</strong>，加入到当前的<strong>微任务队列</strong>中 <ul><li>每个宏任务会创建自己的微任务队列</li></ul></li><li>将遇到的<strong>宏任务</strong>加入<code>push</code><strong>到宏任务队列</strong>中</li><li>然后，<strong>当次宏任务</strong>执行完后，会先清空当前的微任务队列，再去读取下一个宏任务</li></ul></li><li>就是这种不断循环重复的，从任务队列中读取事件的过程，就是事件循环</li></ul><p><img src="'+r+'" alt="eventloop" loading="lazy"></p><p><img src="'+e+'" alt="task" loading="lazy"></p>',16),a=[n];function c(d,g,u,_,h,p){return t(),l("div",null,a)}const k=o(s,[["render",c]]);export{S as __pageData,k as default};
