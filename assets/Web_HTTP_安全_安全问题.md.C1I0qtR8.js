import{_ as l,c as o,o as i,a1 as e}from"./chunks/framework.yskgK-vV.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/HTTP/安全/安全问题.md","filePath":"Web/HTTP/安全/安全问题.md"}'),t={name:"Web/HTTP/安全/安全问题.md"},r=e('<h2 id="安全问题" tabindex="-1">安全问题 <a class="header-anchor" href="#安全问题" aria-label="Permalink to &quot;安全问题&quot;">​</a></h2><h3 id="_01-xss-攻击" tabindex="-1">01. XSS 攻击 <a class="header-anchor" href="#_01-xss-攻击" aria-label="Permalink to &quot;01. XSS 攻击&quot;">​</a></h3><h4 id="_1-基本概念" tabindex="-1">（1）基本概念 <a class="header-anchor" href="#_1-基本概念" aria-label="Permalink to &quot;（1）基本概念&quot;">​</a></h4><ul><li>XSS 攻击就是，页面里被注入了恶意的代码</li><li>例 1： <ul><li>在一些搜索框，或者输入框里，或者一些需要提交的地方，恶意的写一些代码，<code>&lt;script&gt; alert(&#39;XSS&#39;) &lt;/script&gt;</code></li><li>浏览器拿到这个代码后，无法识别这是恶意的代码，就会将其当作<code>&lt;script&gt;</code>来执行</li><li>即，浏览器会把用户的输入<strong>当作脚本执行</strong></li><li>所以这里，只要告诉浏览器这是<strong>文本内容</strong>就好了</li><li>通过<strong>HTML 转义</strong>，就可以防止这种最基本的 XSS 攻击</li></ul></li><li>例 2： <ul><li>在一些标签上，如果我们添加<code>javascript:</code>这个字符串，并且出现在<code>href</code>属性上或者<code>src</code>属性上时</li><li>那么用户点击链接，就会触发 XSS 攻击</li><li>这种情况还有多种变形，如<code>javascript</code>的大小写，在前面加上<code>%20</code>空格符号等等</li><li>所以，这里要检验其内容，并且禁止掉以<code>javascript:</code>开头的链接，和非法的<code>scheme</code></li></ul></li></ul><blockquote><p>如果不对用户输入的文本进行合适的过滤，就会容易造成注入漏洞，容易遭到 XSS 攻击</p></blockquote><hr><h4 id="_2-介绍" tabindex="-1">（2）介绍 <a class="header-anchor" href="#_2-介绍" aria-label="Permalink to &quot;（2）介绍&quot;">​</a></h4><ul><li>XSS：即<strong>跨站脚本攻击</strong>，<code>Cross-Site Scripting</code>，一种代码注入攻击 <ul><li>攻击者在目标网站上注入恶意脚本，并利用这些脚本窃取用户的敏感信息</li><li>其本质是：恶意代码<strong>未经过滤</strong>，与网站正常的代码<strong>混在一起</strong>；浏览器<strong>无法分辨</strong>哪些脚本是可信的，导致恶意脚本<strong>被执行</strong></li><li>这些恶意代码的注入，可以是 <ul><li>来自<strong>用户的输入</strong></li><li>来自<strong>URL 上</strong>的参数</li><li>来自<strong>POST</strong>的参数</li><li>等等...</li></ul></li></ul></li></ul><hr><h4 id="_3-分类" tabindex="-1">（3）分类 <a class="header-anchor" href="#_3-分类" aria-label="Permalink to &quot;（3）分类&quot;">​</a></h4><ul><li><p>XSS 攻击可分为</p><ul><li><strong>存储型</strong>： <ul><li>将恶意代码提交到目标<strong>网站的数据库</strong>中</li><li>当用户打开目标网站时，就会把恶意代码拼接在 HTML 中返回给浏览器</li><li>浏览器接收后就会执行恶意代码</li><li>常见于：论坛发帖、商品评论等</li></ul></li><li><strong>反射型</strong>： <ul><li>由攻击者构建出<strong>特殊的 URL</strong>，包含恶意代码</li><li>当用户打开带有恶意代码的 URL 时，<strong>网站服务端</strong>会将恶意代码取出，拼接在 HTML 中返回给浏览器</li><li>常见于：网站搜索、页面跳转等，由攻击者诱导用户点击</li></ul></li><li><strong>DOM</strong>型： <ul><li>由攻击者构造特殊的 URL，包含恶意代码</li><li>用户打开后，由<strong>浏览器取出并解析</strong>，然后执行</li></ul></li></ul><blockquote><p>由此可知，XSS 攻击有两大要素：</p><ul><li>攻击者提交恶意代码</li><li>浏览器执行恶意代码</li></ul></blockquote></li></ul><hr><h4 id="_4-xss-攻击预防" tabindex="-1">（4）XSS 攻击预防 <a class="header-anchor" href="#_4-xss-攻击预防" aria-label="Permalink to &quot;（4）XSS 攻击预防&quot;">​</a></h4><ul><li><p><strong>输入过滤</strong></p><ul><li><p>如果由前端过滤，再提交到后端是否可行？</p><ul><li>不行，攻击者可绕过前端过滤，直接构造请求，就可以继续提交恶意代码了</li></ul></li><li><p>如果由后端过滤，再返回给前端是否可行？</p><ul><li>不行，因为我们不知道要把过滤后的数据，输出到哪里</li><li>即，不同的位置，前端需要的编码也不同</li><li>容易出现乱码问题</li></ul></li><li><p>所以，输入侧过滤并不完全可靠，有太多的不确定性和乱码问题</p></li><li><p>所以，要通过防止浏览器执行恶意代码的方式来防范 XSS 攻击</p></li></ul></li></ul><hr><ul><li><p><strong>预防存储型和反射型 XSS</strong></p><ul><li>由于存储型和反射型 XSS 都是在服务端取出恶意代码，并插入到 HTML 中，返回给浏览器，进而被浏览器执行的 <ul><li>所以预防这两种漏洞，有两种常见的做法： <ul><li>纯前端渲染，把代码和数据分隔开</li><li>对 HTML 做充分转义</li></ul></li></ul></li><li><strong>纯前端渲染</strong><ul><li>浏览器先加载一个静态 HTML，这个 HTML 中不包含任何业务相关的数据</li><li>然后，由浏览器执行 HTML 中的<code>JavaScrip</code>t 代码</li><li>最后，通过<code>Ajax</code>来加载业务数据，调用<code>DOM API</code>更新到页面上</li></ul></li></ul><blockquote><p>纯前端渲染页面，会告诉浏览器，内容是什么类型的，</p></blockquote><ul><li><strong>转义 HTML</strong><ul><li>主要是把 <code>&amp; &lt; &gt; &quot; &#39; /</code> 这几个字符转义掉</li></ul></li></ul></li></ul><hr><ul><li><p><strong>预防 DOM 型 XSS 攻击</strong></p><ul><li><p>出现 DOM 型 XSS 攻击的原因就是，网站前端的 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了</p></li><li><p>所以，在使用：<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write</code>时要特别小心</p></li><li><p>应尽量使用：<code>.textContent</code>、<code>.setAttribute</code></p></li><li><p>DOM 内联的事件监听器，如</p><ul><li><code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code></li><li><code>&lt;a&gt;</code>标签的<code>href</code>属性，JS 的<code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>等</li><li>这些都可以把字符串当作代码执行</li></ul></li></ul></li></ul><hr><h3 id="_02-csrf-攻击" tabindex="-1">02. CSRF 攻击 <a class="header-anchor" href="#_02-csrf-攻击" aria-label="Permalink to &quot;02. CSRF 攻击&quot;">​</a></h3><h4 id="_1-基本概念-1" tabindex="-1">（1）基本概念 <a class="header-anchor" href="#_1-基本概念-1" aria-label="Permalink to &quot;（1）基本概念&quot;">​</a></h4><ul><li>CSRF，即<strong>跨站请求伪造</strong>，<code>Cross-site request forgery</code><ul><li>攻击者会诱导用户进入第三方网站，这个第三方网站会向被攻击的网站发送跨站请求</li><li>利用用户在被攻击网站已经获取的注册凭证等信息，绕过后台的用户验证</li><li>从而达到冒充用户对被攻击的网站执行某项操作的目的</li></ul></li></ul><h4 id="_2-攻击流程" tabindex="-1">（2）攻击流程 <a class="header-anchor" href="#_2-攻击流程" aria-label="Permalink to &quot;（2）攻击流程&quot;">​</a></h4><ul><li>CSRF 攻击的<strong>流程</strong><ul><li>用户登录了 A 网站，并保留了 A 网站的凭证</li><li>用户被诱导访问了 B 网站</li><li>B 网站向 A 网站发送了一个请求，携带了 A 网站的凭证</li><li>A 网站接收了请求后，对请求进行验证，验证通过</li><li>A 网站执行了用户不知道的操作</li></ul></li></ul><h4 id="_3-攻击类型" tabindex="-1">（3）攻击类型 <a class="header-anchor" href="#_3-攻击类型" aria-label="Permalink to &quot;（3）攻击类型&quot;">​</a></h4><ul><li>CSRF<strong>攻击类型</strong><ul><li>GET 类型： <ul><li>通常将请求地址放在<code>&lt;img&gt;</code>标签中，当用户访问这个页面时，就会自动向目标网站发起跨站请求</li></ul></li><li>POST 类型： <ul><li>通常使用的是一个自动提交的表单，当用户访问这个页面后，会模拟用户行为，自动提交表单</li></ul></li><li>链接类型： <ul><li>一个恶意链接，需要诱导用户点击后才会触发</li></ul></li></ul></li></ul><h4 id="_4-特点" tabindex="-1">（4）特点 <a class="header-anchor" href="#_4-特点" aria-label="Permalink to &quot;（4）特点&quot;">​</a></h4><ul><li>CSRF 的<strong>特点</strong><ul><li>攻击一般发起在<strong>第三方网站</strong>，被攻击网站<strong>无法防止</strong>攻击发生</li><li>攻击是<strong>利用</strong>用户在被攻击网站的<strong>登录凭证</strong>，<strong>冒充</strong>用户提交操作，而不是直接窃取数据</li><li>攻击过程中，攻击者并<strong>不能获取</strong>到用户的登录凭证，仅仅是冒用</li><li>跨站请求可以有多种方式 <ul><li>图片 URL、超链接、CORS、Form 表单提交等等</li></ul></li></ul></li></ul><h4 id="_5-防护" tabindex="-1">（5）防护 <a class="header-anchor" href="#_5-防护" aria-label="Permalink to &quot;（5）防护&quot;">​</a></h4><ul><li><p>阻止不明外域的访问</p><ul><li><p><strong>同源检测</strong></p><ul><li><strong>每一个异步</strong>请求都会携带两个 Header，用于标记来源域名 <ul><li><code>Origin Header</code></li><li><code>Referer Header</code></li></ul></li><li>服务器可以通过解析这两个 Header 中的域名，来确定请求的来源域</li><li>如果无法确定来源域名，就直接禁止请求</li></ul><blockquote><p>同源检测是一个相对简单的方法，但并不是万无一失的</p></blockquote></li><li><p><code>Samesite Cookie</code></p><ul><li><code>Samesite = Strict</code>：严格模式，表示在任何跨域请求中都不会携带<code>Cookie</code>，<code>CSRF</code>攻击没有任何机会</li><li><code>Samesite = Lax</code>：宽松模式，表示从其它页面跳转过来是，可以使用<code>Cookie</code>，安全性较低</li></ul><blockquote><p><code>Same-site</code>的兼容性不太好，且不支持子域</p></blockquote></li></ul></li><li><p>提交是要附加本域才能获取信息</p><ul><li><p><code>CSRF Token</code></p><ul><li>即，服务器要求用户的所有请求，都必须携带一个攻击者无法获取到的 Token</li><li>服务器通过校验请求是否携带正确的 Token，来判断正常的请求和攻击请求</li><li>方法 <ul><li>用户打开页面后，由服务器为用户生成一个<code>Toke</code>，<code>Token</code>通过加密算法进行加密</li><li><code>Token</code>一般需要存在服务器的<code>Session</code>中</li><li>页面提交请求时，需要携带这个<code>Token</code></li><li>最后，由服务器验证这个<code>Token</code>是否正确</li></ul></li></ul><blockquote><p>Token 是一个比较有效的<code>CSRF</code>防护方法，只要页面没有 XSS 漏洞泄露<code>Token</code>，那么接口的<code>CSRF</code>攻击就无法成功</p><p>缺点：实现复杂，工作量大</p></blockquote></li><li><p>双重 Cookie 验证</p><ul><li>用户访问网站时，会向请求的域名注入一个<code>Cookie</code>，内容为随机字符串</li><li>然后，在发起请求时，会取出这个<code>Cookie</code>，并将其添加到 URL 的参数中</li><li>后端就会验证<code>Cookie</code>的字段与 URL 参数中的字段是否一致</li></ul></li></ul></li></ul>',30),c=[r];function a(d,s,n,u,g,h){return i(),o("div",null,c)}const _=l(t,[["render",a]]);export{S as __pageData,_ as default};
