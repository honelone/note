import{_ as a,D as i,c as r,j as l,I as o,w as s,a as t,a3 as n,o as d}from"./chunks/framework.BkEKdGEG.js";const Z=JSON.parse('{"title":"","description":"","frontmatter":{"created":"2023-08-28T00:00:00.000Z","updated":"2023-08-28T00:00:00.000Z"},"headers":[],"relativePath":"vue2/12.Vue-Router（一）.md","filePath":"vue2/12.Vue-Router（一）.md","lastUpdated":1716610678000}'),h={name:"vue2/12.Vue-Router（一）.md"},u=n("",9),c=l("li",null,[l("p",null,[l("code",null,"SPA(single page application)"),t("：单一页面应用程序，只有一个完整的页面")]),l("ul",null,[l("li",null,"它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容"),l("li",null,"单页面应用的核心之一是：更新视图而不重新请求页面")])],-1),_=l("p",null,[l("code",null,"vue-router"),t("在实现单页面前端路由时，提供了两种方式：")],-1),p=n("",1),g=l("h2",{id:"_03-两种模式",tabindex:"-1"},[t("03. 两种模式 "),l("a",{class:"header-anchor",href:"#_03-两种模式","aria-label":'Permalink to "03. 两种模式"'},"​")],-1),k=l("h3",{id:"_1-hash-模式",tabindex:"-1"},[t("（1）Hash 模式 "),l("a",{class:"header-anchor",href:"#_1-hash-模式","aria-label":'Permalink to "（1）Hash 模式"'},"​")],-1),b=l("code",null,"vue-router",-1),y=l("li",null,[l("p",null,"实现原理："),l("ul",null,[l("li",null,"使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载"),l("li",null,[l("code",null,"onhashchange"),t(" 事件：通过这个事件来监测 hash 值的变化，从而更新页面的部分内容")])])],-1),f=l("p",null,"工作方式：",-1),R=l("code",null,"#",-1),m=l("code",null,"#",-1),x=l("strong",null,"滚动到相应位置",-1),E=l("ul",null,[l("li",null,[t("同时，每一次改变"),l("code",null,"#"),t("后的部分，都会在浏览器的"),l("strong",null,"访问历史中"),t("增加一个记录")]),l("li",null,"使用浏览器的【后退】按钮，就可以回到上一个位置")],-1),q=l("strong",null,"不会被包含在 Http 请求中",-1),L=l("code",null,"#",-1),U=l("ul",null,[l("li",null,"因此，对后端来说，即使没有做到对路由全覆盖，也不会返回 404 错误，且改变 hash 不会重新加载页面")],-1),A=l("li",null,[l("p",null,"最后总结："),l("ul",null,[l("li",null,[t("Hash 模式就是通过"),l("strong",null,"锚点值的改变"),t("，根据不同的值，渲染指定 DOM 位置的不同数据")])])],-1),H=l("h3",{id:"_2-history-模式",tabindex:"-1"},[t("（2）History 模式 "),l("a",{class:"header-anchor",href:"#_2-history-模式","aria-label":'Permalink to "（2）History 模式"'},"​")],-1),P=l("blockquote",null,[l("ul",null,[l("li",null,[l("p",null,[t("由于 hash 模式会在 URL 地址中自带"),l("code",null,"#"),t("，这样 URL 地址看上去就不是那么美观")])]),l("li",null,[l("p",null,[t("如果不想要很丑的 hash "),l("code",null,"#"),t("符号，我们可以使用 history 模式")])])])],-1),T=n("",2),S=l("p",null,"工作方式：",-1),v=l("a",{href:"http://xxx.com/user/id%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%A4%9A%E4%BD%99%E7%9A%84%60#%60%E7%AC%A6%E5%8F%B7",target:"_blank",rel:"noreferrer"},"http://xxx.com/user/id，没有多余的`#`符号",-1),C=l("code",null,"# ",-1),V=l("ul",null,[l("li",null,"这个实现需要服务器的支持")],-1),D=l("ul",null,[l("li",null,"因此， 在 URL 匹配不到任何静态资源时，应该返回同一个页面（如首页）")],-1),F=l("li",null,[l("p",null,"最后总结："),l("ul",null,[l("li",null,[t("History 模式就是通过"),l("code",null,"pushState()"),t("方法来对浏览器的浏览记录进行修改，来达到不用请求后端来渲染的效果")])])],-1),I=n("",11);function B(N,j,w,$,O,J){const e=i("font");return d(),r("div",null,[u,l("ul",null,[c,l("li",null,[_,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("Hash 模式")]),_:1}),t("和"),o(e,{color:"blue"},{default:s(()=>[t("History 模式")]),_:1})])]),p])]),g,k,l("ul",null,[l("li",null,[l("p",null,[t("模式配置："),b,t(" 默认 "),o(e,{color:"red"},{default:s(()=>[t("hash 模式 ")]),_:1})])]),y,l("li",null,[f,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（1）")]),_:1}),t("hash 即 URL 中的"),R,t("符号，也称为锚点，代表的是网页中的一个位置")]),l("li",null,[o(e,{color:"blue"},{default:s(()=>[t("（2）")]),_:1}),t("hash 的改变，即改变"),m,t("后的部分，浏览器只会"),x,t("，不会重新加载网页"),E]),l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（3）")]),_:1}),t("hash 出现在 URL 中，但"),q,t("，仅有"),L,t("符号之前的内容会被包含在请求中"),U])])]),A]),H,P,l("ul",null,[T,l("li",null,[S,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（1）")]),_:1}),t("当你使用 history 模式时，URL 正常显示，例如 "),v]),l("li",null,[o(e,{color:"blue"},{default:s(()=>[t("（2）")]),_:1}),t("但因为没有 "),C,t("号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求"),V]),l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（3）")]),_:1}),t("而且由于在发送请求时，前端的 URL 必须和实际请求 URL 一致，否则将返回 404 错误"),D])])]),F]),I])}const z=a(h,[["render",B]]);export{Z as __pageData,z as default};
