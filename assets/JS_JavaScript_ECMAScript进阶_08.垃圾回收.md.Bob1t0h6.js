import{_ as l,c as i,o as a,a1 as t}from"./chunks/framework.yskgK-vV.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"JS/JavaScript/ECMAScript进阶/08.垃圾回收.md","filePath":"JS/JavaScript/ECMAScript进阶/08.垃圾回收.md"}'),e={name:"JS/JavaScript/ECMAScript进阶/08.垃圾回收.md"},r=t('<h2 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h2><h3 id="_01-基本概念" tabindex="-1">01. 基本概念 <a class="header-anchor" href="#_01-基本概念" aria-label="Permalink to &quot;01. 基本概念&quot;">​</a></h3><ul><li>垃圾回收，即<code>GC</code>（<code>Garbage Collection</code>） <ul><li>程序工作过程中会产生很多垃圾，这些垃圾是程序<strong>不用的内存</strong>或者是<strong>之前用过了，以后不会再用的内存空间</strong></li><li>而 <code>GC</code> 就是负责回收垃圾的，他工作在引擎内部，所以对于我们前端来说，<code>GC</code> 过程是相对比较无感的</li><li>这一套引擎执行而对我们又相对无感的操作也就是常说的<strong>垃圾回收机制</strong></li></ul></li><li>在我们写代码时，每创建一个基本类型、对象、函数等，这些都是需要占用内存的 <ul><li>这些内存是由引擎为我们分配的，我们不需要显式手动的去分配内存</li><li>而对于不用的内存空间，我们必须将其释放，否则内存占用越来越高，会导致进程崩溃</li></ul></li></ul><hr><h3 id="_02-回收策略" tabindex="-1">02. 回收策略 <a class="header-anchor" href="#_02-回收策略" aria-label="Permalink to &quot;02. 回收策略&quot;">​</a></h3><ul><li>垃圾回收策略 <ul><li>即，如何发现这些不可达的对象（垃圾）它并给予清理的问题</li><li><code>JavaScript</code> 垃圾回收机制的原理就是：<strong>定期</strong>找出那些不再用到的内存（变量），然后释放其内存 <ul><li>实时开销太大了</li></ul></li><li>一般来说常见的两种方式 <ul><li>标记清除算法</li><li>引用计数算法</li></ul></li></ul></li></ul><h4 id="_1-标记清除算法" tabindex="-1">（1）标记清除算法 <a class="header-anchor" href="#_1-标记清除算法" aria-label="Permalink to &quot;（1）标记清除算法&quot;">​</a></h4><ul><li>概念： <ul><li>标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁</li></ul></li><li>缺点： <ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li><strong>分配速度慢</strong></li></ul></li><li>解决： <ul><li>使用 **标记整理（Mark-Compact）算法 **</li><li>在标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</li></ul></li></ul><h4 id="_2-引用计数算法" tabindex="-1">（2）引用计数算法 <a class="header-anchor" href="#_2-引用计数算法" aria-label="Permalink to &quot;（2）引用计数算法&quot;">​</a></h4><ul><li>概念： <ul><li>它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong></li><li>如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收</li></ul></li><li>缺点： <ul><li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限</li><li>无法解决循环引用导致的无法回收问题</li></ul></li></ul><hr><h3 id="_03-v8-对-gc-的优化" tabindex="-1">03. V8 对 GC 的优化 <a class="header-anchor" href="#_03-v8-对-gc-的优化" aria-label="Permalink to &quot;03. V8 对 GC 的优化&quot;">​</a></h3><ul><li>分代式垃圾回收</li><li>并行回收</li><li>并发回收</li></ul>',13),o=[r];function n(c,s,u,_,d,h){return a(),i("div",null,o)}const m=l(e,[["render",n]]);export{p as __pageData,m as default};
