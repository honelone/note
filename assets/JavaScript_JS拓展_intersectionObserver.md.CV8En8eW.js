import{_ as s,c as i,o as a,a3 as e}from"./chunks/framework.BkEKdGEG.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"created":"2023-08-20T00:00:00.000Z","updated":"2023-08-20T00:00:00.000Z"},"headers":[],"relativePath":"JavaScript/JS拓展/intersectionObserver.md","filePath":"JavaScript/JS拓展/intersectionObserver.md","lastUpdated":1716610678000}'),n={name:"JavaScript/JS拓展/intersectionObserver.md"},l=e(`<h2 id="可视区域" tabindex="-1">可视区域 <a class="header-anchor" href="#可视区域" aria-label="Permalink to &quot;可视区域&quot;">​</a></h2><blockquote><p>要了解某个元素是否进入了<strong>视口</strong>（<code>viewport</code>）</p></blockquote><ul><li><p>监听<code>scroll</code>事件后，调用目标元素的<code>getBoundingClientRect()</code>方法，得到它对应于<strong>视口左上角</strong>的坐标，再判断是否在视口之内</p><blockquote><p>由于<code>scroll</code>事件密集发生，计算量很大，容易造成性能问题</p></blockquote></li><li><p>利用<strong>交叉观察器</strong>——<code>IntersectionObserver</code>，判断目标元素与视口是否产生一个<strong>交叉区</strong>，可以自动观察元素是否可见</p><ul><li><p>基本语法</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IntersectionObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback, option);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><p><code>IntersectionObserver</code>：浏览器原生提供的构造函数，可以接收两个参数</p></li><li><p><code>callback</code>：可见性变化时的回调函数</p></li><li><p><code>options</code>：配置对象，可选参数</p></li></ul></li><li><p>构造函数的返回值是一个观察期实例</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unobserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><code>observe</code>：用于指定观察的 DOM 节点，可以多次调用以观察多个节点</li><li><code>unobserve</code>：停止观察</li><li><code>disconnect</code>：关闭观察器</li></ul></li><li><p>目标元素的可见性变化时，就会调用<code>callback</code>函数</p><ul><li><p><code>callback</code>一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> io </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IntersectionObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entries);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li></ul></li></ul>`,3),t=[l];function p(r,h,o,c,d,k){return a(),i("div",null,t)}const b=s(n,[["render",p]]);export{g as __pageData,b as default};
