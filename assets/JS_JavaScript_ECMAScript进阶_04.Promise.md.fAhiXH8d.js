import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.yskgK-vV.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"JS/JavaScript/ECMAScript进阶/04.Promise.md","filePath":"JS/JavaScript/ECMAScript进阶/04.Promise.md"}'),l={name:"JS/JavaScript/ECMAScript进阶/04.Promise.md"},n=e(`<h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><h3 id="_01-基本概念" tabindex="-1">01. 基本概念 <a class="header-anchor" href="#_01-基本概念" aria-label="Permalink to &quot;01. 基本概念&quot;">​</a></h3><h4 id="_1-定义" tabindex="-1">（1）定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to &quot;（1）定义&quot;">​</a></h4><ul><li><code>Promise</code>是： <ul><li>是异步编程的一种解决方法</li><li>从语法上讲：<code>Promise</code>是一个对象，可以获取异步操作的消息</li><li>从本意上讲：<code>Promise</code>表示承诺，它承诺过一段时间会给你一个结果</li><li><code>Promise</code>创建后会立即执行，他是一个同步任务</li></ul></li></ul><h4 id="_2-作用" tabindex="-1">（2）作用 <a class="header-anchor" href="#_2-作用" aria-label="Permalink to &quot;（2）作用&quot;">​</a></h4><ul><li><code>Promise</code>对象可以： <ul><li>表示一个<strong>异步操作</strong>的<strong>最终完成（或者失败）及其结果值</strong></li><li>可以解决回调地狱的缺陷</li></ul></li></ul><h4 id="_3-状态" tabindex="-1">（3）状态 <a class="header-anchor" href="#_3-状态" aria-label="Permalink to &quot;（3）状态&quot;">​</a></h4><ul><li><p>初始化状态：<strong>pending</strong>，表示操作进行中</p></li><li><p>已兑现状态：<strong>fulfilled</strong>，表示操作成功</p></li><li><p>已拒绝状态：<strong>rejected</strong>，表示操作失败</p><blockquote><p><code>Promise</code>在创建时，状态为<code>pending</code>，<strong>状态一经改变就无法再改变</strong> 且，状态改变只有两种情况：<code>pending</code>=&gt; <code>fulfilled</code>、<code>pending</code>=&gt; <code>rejected</code> 状态改变后，就称为<code>resolved</code>，表示状态已经决定了</p></blockquote></li></ul><h3 id="_02-基本使用" tabindex="-1">02. 基本使用 <a class="header-anchor" href="#_02-基本使用" aria-label="Permalink to &quot;02. 基本使用&quot;">​</a></h3><ul><li><p><code>Promise</code>是一个构造函数，需要结合<code>new</code>使用</p></li><li><p><code>Promise</code><strong>接收一个函数作为参数</strong></p><ul><li>这个函数包含两个参数<code>resolve</code>和<code>reject</code></li></ul><blockquote><ul><li><code>resolve</code>：异步操作成功时调用，并会将成功结果作为参数传递出去 <ul><li>其作用就是将<code>Promise</code>的状态从<code>pending</code>改变为<code>resolved</code></li></ul></li><li><code>reject</code>：异步操作失败时调用，并将失败的错误作为参数传递出去 <ul><li>其作用就是将<code>Promise</code>的状态从<code>pending</code>改变为<code>rejected</code></li></ul></li></ul></blockquote></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (success) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(success);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><ul><li>即使异步操作已经完成（成功或失败）</li><li>但在这之后通过 <code>.then()</code>添加的回调函数也会被调用</li><li>通过多次调用 <code>.then()</code> 可以添加多个回调函数，它们会按照插入顺序进行执行</li></ul></blockquote><h3 id="_03-返回值的处理" tabindex="-1">03. 返回值的处理 <a class="header-anchor" href="#_03-返回值的处理" aria-label="Permalink to &quot;03. 返回值的处理&quot;">​</a></h3><ul><li><code>Promise</code>中的任意返回值都会被包裹为<code>promise</code>对象 <ul><li>但不能返回<code>Promise</code>本身，否则死循环</li></ul></li></ul><h4 id="_1-then" tabindex="-1">（1）then <a class="header-anchor" href="#_1-then" aria-label="Permalink to &quot;（1）then&quot;">​</a></h4><ul><li><code>.then()</code>方法可以接受<strong>两个回调函数</strong>作为参数 <ul><li>第一个回调函数是：异步操作成功时调用</li><li>第二个回调函数是：异步操作失败时调用，非必填</li></ul></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">success</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_2-catch" tabindex="-1">（2）catch <a class="header-anchor" href="#_2-catch" aria-label="Permalink to &quot;（2）catch&quot;">​</a></h4><ul><li><code>.then()</code>会在操作成功时执行，<code>.catch()</code>会在操作失败时执行 <ul><li><code>.catch()</code>方法可以看作是<code>.then(null,failureCallback)</code>的缩略形式</li></ul></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // success</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // error</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_3-finally" tabindex="-1">（3）finally <a class="header-anchor" href="#_3-finally" aria-label="Permalink to &quot;（3）finally&quot;">​</a></h4><ul><li><code>.finally</code>方法在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数 <ul><li>回调函数不需要传入参数</li><li>其返回值也是一个<code>Promise</code>，是上一次的<code>Promise</code>对象的值 <ul><li>如果是异常，则返回异常的<code>Promise</code>对象、</li></ul></li></ul></li></ul><h4 id="_4-all" tabindex="-1">（4）all <a class="header-anchor" href="#_4-all" aria-label="Permalink to &quot;（4）all&quot;">​</a></h4><ul><li><code>.all()</code>接收一个<code>Promise</code><strong>对象数组</strong>作为参数 <ul><li>它可以<strong>并行执行多个异步操作</strong></li><li>并且在所有异步操作执行完成后，才执行回调</li><li>且只有全部为<code>resolve</code>时，才会在<code>.then()</code>里接收</li><li>可以在<code>.then()</code>回调里接收<strong>所有的异步处理结果</strong>，结果顺序和数组顺序一致</li></ul></li></ul><h4 id="_5-race" tabindex="-1">（5）race <a class="header-anchor" href="#_5-race" aria-label="Permalink to &quot;（5）race&quot;">​</a></h4><ul><li><code>.race()</code>接收一个<code>Promise</code><strong>对象数组</strong>作为参数 <ul><li>它可以<strong>并行执行多个异步操作</strong></li><li>且，只会保留取<strong>第一个执行完成的异步操作的结果</strong></li><li>其它方法仍然会执行，不过执行结果会被抛弃</li></ul></li></ul><h4 id="_6-链式调用" tabindex="-1">（6）链式调用 <a class="header-anchor" href="#_6-链式调用" aria-label="Permalink to &quot;（6）链式调用&quot;">​</a></h4><ul><li><code>Promise</code>可以进行<strong>链式调用、多次调用</strong><ul><li>链式调用：<code>Promise.then().catch()</code></li><li>多次调用：<code>Promise.then()</code>、<code>Promise.then()</code></li></ul></li><li>但<code>Promise</code>的构造函数<strong>只会执行一次</strong>，且<strong>状态一经改变就不再变化</strong><ul><li>因此，后续每次调用<code>.then()</code>或者<code>.catch()</code>都会直接拿到构造函数返回值</li></ul></li></ul><h4 id="_7-值透传" tabindex="-1">（7）值透传 <a class="header-anchor" href="#_7-值透传" aria-label="Permalink to &quot;（7）值透传&quot;">​</a></h4><ul><li><code>.then</code>或者<code> .catch</code>的参数期望是函数，<strong>传入非函数</strong>则会发生<strong>值透传</strong><ul><li>一个是数字类型，一个是对象类型</li><li>因此发生了透传，将<code>resolve(1)</code> 的值直接传到了最后一个<code>then</code>里</li></ul></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(console.log);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出结果： 1第一个then和第二个then中传入的都不是函数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_04-错误处理" tabindex="-1">04. 错误处理 <a class="header-anchor" href="#_04-错误处理" aria-label="Permalink to &quot;04. 错误处理&quot;">​</a></h3><h4 id="_1-抛出错误" tabindex="-1">（1）抛出错误 <a class="header-anchor" href="#_1-抛出错误" aria-label="Permalink to &quot;（1）抛出错误&quot;">​</a></h4><ul><li>在<code>.then()</code>中 <ul><li>可以通过<code>throw new Error()</code>抛出错误</li><li>可以通过<code>return Promise.reject(new Error(&#39;错误信息&#39;))</code>返回错误</li></ul></li></ul><h4 id="_2-接收错误" tabindex="-1">（2）接收错误 <a class="header-anchor" href="#_2-接收错误" aria-label="Permalink to &quot;（2）接收错误&quot;">​</a></h4><ul><li><p>通过<code>throw</code>抛出的错误，可以在<code>.catch()</code>中接收这个错误</p></li><li><p>通过<code>return</code>返回错误，则会被包裹为<code>Promise</code>对象，无法被<code>.catch()</code>捕获</p><blockquote><p>在链式调用中，<code>.catch()</code>不管被链接到哪里，都可以捕获到<strong>上层未捕捉的错误</strong></p></blockquote></li></ul><h3 id="_05-同步和异步" tabindex="-1">05. 同步和异步 <a class="header-anchor" href="#_05-同步和异步" aria-label="Permalink to &quot;05. 同步和异步&quot;">​</a></h3><ul><li><code>Promise</code>新建后立即执行，即<code>Promise</code><strong>构造函数里的代码同步执行</strong>的</li><li>而当<code>Promise</code><strong>状态结束的时候</strong>，就会立即<strong>放进异步队列中</strong><ul><li><code>.then()</code>函数是异步的，需要在 JS 事件队列所有运行事件结束了，且事件队列被清空之后，才开始执行</li><li><code>.then()</code>需要在回调函数<code>resolve</code>之后，才会执行里面的内容</li></ul></li></ul><h3 id="_06-async-await" tabindex="-1">06. async/await <a class="header-anchor" href="#_06-async-await" aria-label="Permalink to &quot;06. async/await&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // await 前面的代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // await 后面的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>分析： <ul><li><code>await</code><strong>前面的代码</strong> 是同步执行的， <ul><li>它相当于函数<code>foo</code>内部的同步代码</li><li>调用函数时会直接执行（当然要遵循事件循环机制）</li></ul></li><li><code>await</code><strong>所在行的代码</strong>会从右往左执行，或者说，<code>await</code>后面的函数会先执行一遍 <ul><li>它相当于<code>Promise()</code>构造函数内的代码 <ul><li>注：是构造函数内，而不是回调函数</li></ul></li><li>所以它也是同步执行的</li><li><code>await</code>表示等待右侧表达式完成</li></ul></li><li><code>await</code><strong>后面的代码</strong>则会被放到 <code>Promise</code> 的 <code>.then()</code> 方法里</li><li>所以<code>async/await</code>可以转换为：</li></ul></li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // await 前面的代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // await 后面的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>错误处理 <ul><li>如果<code>await</code>所在行的代码，后面返回的结果是一个状态为<code>rejected</code>的<code>Promise</code>对象 <ul><li>那么，代码执行到这里就会返回结果，并且不会再继续向下执行</li></ul></li><li>为了避免这个问题 <ul><li>可以在后面直接跟上<code>.catch()</code></li><li>可以使用<code>try catch</code></li></ul></li></ul></li></ul>`,43),t=[n];function r(h,p,o,c,d,k){return a(),i("div",null,t)}const g=s(l,[["render",r]]);export{E as __pageData,g as default};
