import{_ as o,c as i,o as e,a1 as s}from"./chunks/framework.yskgK-vV.js";const l="/note/assets/http1.tILQuzAS.png",t="/note/assets/http2.Dk9aum5G.png",n="/note/assets/http3.B3cLkmJd.png",C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/HTTP/基础知识/前端网络知识.md","filePath":"Web/HTTP/基础知识/前端网络知识.md"}'),a={name:"Web/HTTP/基础知识/前端网络知识.md"},r=s('<h2 id="http-网络知识" tabindex="-1">HTTP 网络知识 <a class="header-anchor" href="#http-网络知识" aria-label="Permalink to &quot;HTTP 网络知识&quot;">​</a></h2><h3 id="_01-http-报文结构" tabindex="-1">01. HTTP 报文结构 <a class="header-anchor" href="#_01-http-报文结构" aria-label="Permalink to &quot;01. HTTP 报文结构&quot;">​</a></h3><ul><li><p><strong>起始行</strong></p><ul><li>请求报文：<code>GET /home HTTP/1.1</code><ul><li>即：<strong>方法 + 路径 + HTTP 版本</strong></li></ul></li><li>响应报文：<code>HTTP/1.1 200 OK</code><ul><li>即：<strong>HTTP 版本 + 状态码 + 原因</strong></li><li>原因：指的是状态码的原因，如<code>200 ok</code>、<code>400 Not Found</code></li></ul></li></ul><blockquote><ul><li><p>用<strong>空格</strong>隔开</p></li><li><p>最后一个部分后面接一个<strong>换行</strong></p></li></ul></blockquote></li><li><p><strong>首部字段</strong></p><ul><li><p>请求头</p></li><li><p>响应头</p><img src="'+l+'" alt="img" style="zoom:67%;"></li></ul></li><li><p><strong>空行</strong></p><ul><li><p>头部和实体之间<strong>必须要有一个空行</strong>，用以<strong>区分头部和实体</strong></p></li><li><p>这个空行是<code>CR</code>回车符，或者<code>LF</code>换行符</p><blockquote><p>注意：如果在头部中故意加一个空行，那么后面的所有内容都会被当成实体来处理</p></blockquote></li></ul></li><li><p><strong>实体</strong></p><ul><li>具体的数据，也就是<code>body</code>部分 <ul><li>请求报文对应<strong>请求体</strong></li><li>响应报文对应<strong>响应体</strong></li></ul></li></ul><img src="'+t+'" alt="img" style="zoom:67%;"></li></ul><h3 id="_02-http-请求方法" tabindex="-1">02. HTTP 请求方法 <a class="header-anchor" href="#_02-http-请求方法" aria-label="Permalink to &quot;02. HTTP 请求方法&quot;">​</a></h3><ul><li><p><code>GET</code>请求：通常用来获取紫竹院</p></li><li><p><code>POST</code>请求：通常用于提交数据、上传数据</p></li><li><p><code>PUT</code>请求：用于修改数据</p></li><li><p><code>DELETE</code>请求：删除资源</p></li><li><p><code>GET</code>和<code>POST</code>的区别</p><ul><li>从缓存角度：GET 会主动缓存，POST 不会</li><li>从编码角度：GET 只能进行 URL 编码，只能接收 ASCII 字符，POST 没有限制</li><li>从参数角度：GET 在 URL 上传参，POST 在请求体里</li><li>从幂等角度：GET 是幂等的，POST 不是</li></ul></li></ul><h3 id="_03-uri" tabindex="-1">03. URI <a class="header-anchor" href="#_03-uri" aria-label="Permalink to &quot;03. URI&quot;">​</a></h3><ul><li><p>URI，全称统一资源标识符（<code>Uniform Resource Identifier</code>），主要用于区分互联网上不同的资源</p></li><li><p>URL，才是网站，URI 包含 URN 和 URL 两个部分</p></li><li><p>URI 的结构</p><ul><li><p><code>scheme</code>+<code>://</code>+<code>user:passwd@</code>+<code>host:port</code>+<code>path</code>+<code>?query</code>+<code>#fragment</code></p></li><li><p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起</p></li><li><p><strong>user:passwd@</strong> 表示登录主机时的用户信息，不过很不安全，不推荐使用</p></li><li><p><strong>host:port</strong>表示主机名和端口</p></li><li><p><strong>path</strong>表示请求路径，标记资源所在位置</p></li><li><p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开</p></li><li><p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置</p></li></ul></li><li><p>URI 只能使用<code>ASCII</code>编码，其它字符不支持 显示</p></li></ul><h3 id="_04-状态码" tabindex="-1">04. 状态码 <a class="header-anchor" href="#_04-状态码" aria-label="Permalink to &quot;04. 状态码&quot;">​</a></h3><ul><li>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类: <ul><li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作</li><li><strong>2xx</strong>: 表示成功状态 <ul><li>200：请求成功，带响应体</li><li>204：请求成功，不带响应体</li></ul></li><li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求 <ul><li>301：永久重定向</li><li>302：临时重定向</li><li>303：临时重定向，明确表示客户端应该使用 GET 方法</li><li>304：</li><li>307：临时重定向，请求方法和实体都不允许变动</li></ul></li><li><strong>4xx</strong>: 请求报文有误 <ul><li>400：请求报文语法错误</li><li>401：认证失败</li><li>403：被拒绝</li><li>404：未找到资源</li></ul></li><li><strong>5xx</strong>: 服务器端发生错误 <ul><li>500：服务器内部错误</li><li>501：不支持客户端的请求功能</li><li>502：代理服务器无法获取相应</li><li>503：服务器超负荷状态，或进行停机维护</li></ul></li></ul></li></ul><hr><h2 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h2><h3 id="_01-概念" tabindex="-1">01. 概念 <a class="header-anchor" href="#_01-概念" aria-label="Permalink to &quot;01. 概念&quot;">​</a></h3><ul><li><p>在请求报文和响应报文中写入<code>cookie</code>来控制客户端的状态，解决 HTTP 无状态的问题</p><ul><li>其本质就是存储在浏览器上的一个文本文件</li></ul></li><li><p>它是为了解决客户端与服务端会话状态的问题</p></li></ul><h3 id="_02-首部字段" tabindex="-1">02. 首部字段 <a class="header-anchor" href="#_02-首部字段" aria-label="Permalink to &quot;02. 首部字段&quot;">​</a></h3><ul><li><p><code>Set-Cookie</code></p><ul><li>作用：在响应报文首部设置要传递给客户端的<code>Cookie</code>信息</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xxx; HttpOnly</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>Cookie</code></p><ul><li>作用：客户端传递给服务端的<code>Cookie</code>信息</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xxx;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul><h3 id="_03-生命周期" tabindex="-1">03. 生命周期 <a class="header-anchor" href="#_03-生命周期" aria-label="Permalink to &quot;03. 生命周期&quot;">​</a></h3><ul><li><code>expires = date</code><ul><li>作用：设置一个具体的时间</li></ul></li><li><code>max-age = TIME</code><ul><li>作用：设置一段时间</li><li><code>max-age = 0</code>：表示删除该<code>cookie</code></li><li><code>max-age</code>为正数：表示<code>cookie</code>可持久化，在这段时间内打开，<code>cookie</code>仍然有效</li><li><code>max-age</code>为负数：表示<code>cookie</code>为临时性存储，关闭窗口后即失效</li></ul></li></ul><h3 id="_04-作用域" tabindex="-1">04. 作用域 <a class="header-anchor" href="#_04-作用域" aria-label="Permalink to &quot;04. 作用域&quot;">​</a></h3><ul><li><p><code>domain</code></p><ul><li>作用：指定<code>Cookie</code>可以送达的主机名</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.example.com</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>path</code></p><ul><li>作用：指定一个 URL 路径，表示<code>Cookie</code>只会被添加到这个指定的 URL 路径的请求报文首部上</li><li>默认值为<code>/</code>，也就是所有的 URL 路径都会携带<code>Cookie</code></li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul><h3 id="_05-安全性" tabindex="-1">05. 安全性 <a class="header-anchor" href="#_05-安全性" aria-label="Permalink to &quot;05. 安全性&quot;">​</a></h3><ul><li><code>Secure</code><ul><li>作用：表示<code>Cookie</code>只在<code>HTTPS</code>下传输</li></ul></li><li><code>HttpOnly</code><ul><li>作用：表示<code>Cookie</code>只能通过<code>HTTP</code>协议传输，不能通过<code>JS</code>脚本访问</li><li>可以一定程度上预防<code>XSS</code>攻击 <ul><li>很多<code>XSS</code>攻击都是通过盗用<code>Cookie</code></li></ul></li></ul></li><li><code>SameSite</code><ul><li>作用：用来限制第三方<code>Cookie</code>，一般用来防范<code>CSRF</code>攻击</li></ul></li></ul><h3 id="_06-作用" tabindex="-1">06. 作用 <a class="header-anchor" href="#_06-作用" aria-label="Permalink to &quot;06. 作用&quot;">​</a></h3><ul><li>会话状态管理</li><li>个性化设置</li><li>浏览器行为跟踪</li></ul><h3 id="_07-缺点" tabindex="-1">07. 缺点 <a class="header-anchor" href="#_07-缺点" aria-label="Permalink to &quot;07. 缺点&quot;">​</a></h3><ul><li>容量缺陷</li><li>性能缺陷</li><li>安全缺陷</li></ul><img src="'+n+'" alt="img" style="zoom:67%;"><h2 id="其它问题" tabindex="-1">其它问题 <a class="header-anchor" href="#其它问题" aria-label="Permalink to &quot;其它问题&quot;">​</a></h2><h3 id="_04-什么是-cookie" tabindex="-1">04. 什么是 Cookie？ <a class="header-anchor" href="#_04-什么是-cookie" aria-label="Permalink to &quot;04. 什么是 Cookie？&quot;">​</a></h3><ul><li><p>HTTP 是无状态的协议</p><ul><li>即，对事务处理<strong>没有记忆能力</strong>，每次客户端和服务端会话完成时，服务端<strong>不会保存任何会话信息</strong></li><li>这样，每次请求都会是完全独立的，服务端也就<strong>无法确认和分辨</strong>当前访问者的身份信息</li><li>所以，为了进行会话跟踪，就必须要主动的去<strong>维护一个状态</strong>，这个状态用于告诉服务端当前访问者的<strong>身份信息</strong></li><li>这种状态就是通过<strong>Cookie</strong>，或者<strong>Session</strong>去实现的</li></ul></li><li><p><strong>Cookie</strong>是存储在客户端的：</p><ul><li><strong>Cookie</strong>是服务器通过<code>Set-Cookie</code>发送到客户端，并由客户端存储在本地的一小块数据</li><li>并且，它会在下次请求时，被设置在<code>Cookie</code>字段里</li></ul></li><li><p><strong>Cookie</strong>是不可跨域的：</p><ul><li>每个<code>Cookie</code>都会绑定单一的域名，是无法在其它域名下获取使用的</li><li>一级域名和二级域名之间是允许共享使用的，通过<strong>domain</strong></li></ul></li><li><p><strong>Cookie</strong>的属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，用于设置<strong>Cookie</strong>的名称，和对应的值，都是字符串类型</td></tr><tr><td><strong>domain</strong></td><td>指定<strong>Cookie</strong>的所属域名，默认为当前域名</td></tr><tr><td><strong>path</strong></td><td>指定<strong>Cookie</strong>在哪一个路径（路由）下生效，默认为<code>/</code></td></tr><tr><td><strong>maxAge</strong></td><td><strong>Cookie</strong>的失效时间，单位为秒。正数：表示<code>maxAge</code>秒后失效；负数：临时<code>cookie</code>，关闭浏览器即失效；<strong>0</strong>：删除该<code>cookie</code>。默认值为**-1**</td></tr><tr><td><strong>expires</strong></td><td>设置过期日期，在这个日期之后的时间<strong>Cookie</strong>失效</td></tr><tr><td><strong>secure</strong></td><td>是否使用安全协议传输。安全协议有<code>HTTPS</code>、<code>SSL</code>等。默认为<code>false</code></td></tr><tr><td><strong>httpOnly</strong></td><td>设置该属性可防止通过 JS 脚本读取<strong>Cookie</strong>信息</td></tr></tbody></table></li></ul><h3 id="_05-什么是-session" tabindex="-1">05. 什么是 Session？ <a class="header-anchor" href="#_05-什么是-session" aria-label="Permalink to &quot;05. 什么是 Session？&quot;">​</a></h3><ul><li><p>基本概念</p><ul><li><strong>Session</strong>是另一种<strong>记录服务器和客户端会话状态</strong>的机制</li><li><strong>Session</strong>是基于<strong>Cookie</strong>实现的，<strong>Session</strong>存储在服务器端，<strong>sessionId</strong>会被存储到客户端的<strong>Cookie</strong>中</li></ul></li><li><p><strong>Session</strong>的认证流程：</p><ul><li>用户第一次请求服务器的时候，服务器会根据用户提交的相关信息，创建对应的<strong>Session</strong></li><li>在返回请求时，会将该<strong>Session</strong>的唯一标识信息<strong>Session ID</strong>，返回给浏览器</li><li>浏览器接收到<strong>Session ID</strong>后，会将此信息存入到<strong>Cookie</strong>中，并在<strong>Cookie</strong>中记录所属域名</li><li>在下次请求时，会判断当前域名下是否存在<strong>Cookie</strong>信息，如果存在，就会将<strong>Cookie</strong>信息一起发送给服务端</li><li>服务端会从<strong>Cookie</strong>中获取<strong>Session Id</strong>，再根据<strong>Session Id</strong>去查找对应的<strong>Session</strong>信息</li><li>如果没有找到，则表示没有登录，或者登录失效；如果找到了，则表示已经登录，可继续执行后面操作</li></ul><blockquote><p><strong>Session ID</strong>是连接<strong>Cookie</strong>和<strong>Session</strong>的一道桥梁</p></blockquote></li></ul><h3 id="_06-cookie-和-session-的区别" tabindex="-1">06. Cookie 和 Session 的区别？ <a class="header-anchor" href="#_06-cookie-和-session-的区别" aria-label="Permalink to &quot;06. Cookie 和 Session 的区别？&quot;">​</a></h3><ul><li><p>安全性：<strong>Session</strong>比<strong>Cookie</strong>安全。<strong>Session</strong>存储在服务器端，<strong>Cookie</strong>存储在客户端</p></li><li><p>存取值的类型不同：<strong>Cookie</strong>只支持字符串数据，<strong>Session</strong>支持任意数据类型</p></li><li><p>有效期不同：<strong>Cookie</strong>可设置长时间保持，<strong>Session</strong>的失效时间较短，客户端关闭或者<strong>Session</strong>超时都会失效、</p></li><li><p>存储大小不同：<strong>Cookie</strong>的数据一般不同超过<strong>4k</strong>，<strong>Session</strong>可存储数据原告于<strong>Cookie</strong></p></li></ul>',33),d=[r];function c(g,p,h,u,k,m){return e(),i("div",null,d)}const _=o(a,[["render",c]]);export{C as __pageData,_ as default};
