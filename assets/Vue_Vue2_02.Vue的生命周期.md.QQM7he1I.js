import{_ as e,c as a,o,a1 as t}from"./chunks/framework.yskgK-vV.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Vue/Vue2/02.Vue的生命周期.md","filePath":"Vue/Vue2/02.Vue的生命周期.md"}'),i={name:"Vue/Vue2/02.Vue的生命周期.md"},l=t(`<h2 id="vue-的生命周期" tabindex="-1">VUE 的生命周期 <a class="header-anchor" href="#vue-的生命周期" aria-label="Permalink to &quot;VUE 的生命周期&quot;">​</a></h2><h3 id="_01-什么是-vue-生命周期" tabindex="-1">01. 什么是 vue 生命周期？ <a class="header-anchor" href="#_01-什么是-vue-生命周期" aria-label="Permalink to &quot;01. 什么是 vue 生命周期？&quot;">​</a></h3><ul><li>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期</li></ul><h3 id="_02-vue-生命周期的作用是什么" tabindex="-1">02. vue 生命周期的作用是什么？ <a class="header-anchor" href="#_02-vue-生命周期的作用是什么" aria-label="Permalink to &quot;02. vue 生命周期的作用是什么？&quot;">​</a></h3><ul><li>生命周期中有多个事件钩子，可以让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑，可以在不同阶段添加自己的代码</li></ul><h3 id="_03-vue-生命周期总共有几个阶段" tabindex="-1">03. vue 生命周期总共有几个阶段？ <a class="header-anchor" href="#_03-vue-生命周期总共有几个阶段" aria-label="Permalink to &quot;03. vue 生命周期总共有几个阶段？&quot;">​</a></h3><ul><li>它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</li></ul><h4 id="_1-create" tabindex="-1">（1）Create <a class="header-anchor" href="#_1-create" aria-label="Permalink to &quot;（1）Create&quot;">​</a></h4><ul><li><code>beforeCreate</code>：数据观测前，data 和 methods 中的数据都还<strong>没有初始化</strong></li><li><code>created</code>：完成数据观测，data 和 methods 都已经被<strong>初始化好了</strong>，最早可以在这个阶段操作数据或者方法</li></ul><h4 id="_2-mount" tabindex="-1">（2）Mount <a class="header-anchor" href="#_2-mount" aria-label="Permalink to &quot;（2）Mount&quot;">​</a></h4><ul><li><code>beforeMount</code>：在内存中已经编译好了模板了，但是还<strong>没有挂载到页面</strong>中，此时，页面还是旧的</li><li><code>Mounted</code>：Vue 实例<strong>挂载完成</strong>，内存中编译好的模板替换 el 属性指向的 DOM 对象。此时已经初始化完成，脱离了创建阶段，进入到了<strong>运行阶段</strong>，最早可以在这个阶段操作 DOM 节点</li></ul><h4 id="_3-update" tabindex="-1">（3）Update <a class="header-anchor" href="#_3-update" aria-label="Permalink to &quot;（3）Update&quot;">​</a></h4><ul><li><p><code>beforeUpdate</code>：发生在虚拟 DOM 重新渲染和打补丁之前，页面中的显示的数据还是旧的，data 中的数据是更新后的， 页面还没有和最新的数据保持同步，</p></li><li><p><code>Updated</code>：页面显示的数据和 data 中的数据已经保持同步了，都是最新的，可以执行依赖于 DOM 的操作</p><blockquote><p>应避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用</p></blockquote></li></ul><h4 id="_4-destory" tabindex="-1">（4）Destory <a class="header-anchor" href="#_4-destory" aria-label="Permalink to &quot;（4）Destory&quot;">​</a></h4><ul><li><code>beforeDestory</code>：从运行阶段进入到了<strong>销毁阶段</strong>，数据还处于可用状态，还没有真正被销毁</li><li><code>Destroyed</code>：所有内容处于不可用状态，组件已经被销毁，调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用</li></ul><h3 id="_04-额外的周期" tabindex="-1">04.额外的周期 <a class="header-anchor" href="#_04-额外的周期" aria-label="Permalink to &quot;04.额外的周期&quot;">​</a></h3><h4 id="_1-activated" tabindex="-1">（1）activated <a class="header-anchor" href="#_1-activated" aria-label="Permalink to &quot;（1）activated&quot;">​</a></h4><ul><li>在<code>keep-alive</code>组件激活时才调用，该钩子函数在服务器端渲染期间不被调用</li></ul><h4 id="_2-deactivated" tabindex="-1">（2）deactivated <a class="header-anchor" href="#_2-deactivated" aria-label="Permalink to &quot;（2）deactivated&quot;">​</a></h4><ul><li>在<code>keep-alive</code>组件停用时调用</li></ul><h4 id="_3-errorcaptured" tabindex="-1">（3）errorCaptured <a class="header-anchor" href="#_3-errorcaptured" aria-label="Permalink to &quot;（3）errorCaptured&quot;">​</a></h4><ul><li>当捕获一个来自子孙组件的错误时被调用</li></ul><h3 id="_05-第一次页面加载会触发哪几个钩子" tabindex="-1">05. 第一次页面加载会触发哪几个钩子？ <a class="header-anchor" href="#_05-第一次页面加载会触发哪几个钩子" aria-label="Permalink to &quot;05. 第一次页面加载会触发哪几个钩子？&quot;">​</a></h3><ul><li>会触发下面这几个<code>beforeCreate, created, beforeMount, mounted </code></li></ul><h3 id="_06-dom-渲染在哪个周期中就已经完成" tabindex="-1">06. DOM 渲染在哪个周期中就已经完成？ <a class="header-anchor" href="#_06-dom-渲染在哪个周期中就已经完成" aria-label="Permalink to &quot;06. DOM 渲染在哪个周期中就已经完成？&quot;">​</a></h3><ul><li>DOM 渲染在 <code>mounted</code> 中就已经完成了</li></ul><h3 id="_07-获取数据在哪一个周期函数" tabindex="-1">07. 获取数据在哪一个周期函数？ <a class="header-anchor" href="#_07-获取数据在哪一个周期函数" aria-label="Permalink to &quot;07. 获取数据在哪一个周期函数？&quot;">​</a></h3><ul><li>一般在<code>created</code>周期就可以获取数据了</li><li>如果涉及到需要页面加载完成之后就在<code>mounted</code>周期进行数据获取</li></ul><h3 id="_08-created-和-mounted-的区别" tabindex="-1">08. created 和 mounted 的区别？ <a class="header-anchor" href="#_08-created-和-mounted-的区别" aria-label="Permalink to &quot;08. created 和 mounted 的区别？&quot;">​</a></h3><ul><li><p><code>created</code>：在模板渲染成 html 前调用，即通常<strong>初始化某些属性值</strong>，然后再渲染成视图</p></li><li><p><code>mounted</code>：在模板渲染成 html 后调用，通常是<strong>初始化页面</strong>完成后，再对 html 的 dom 节点进行一些需要的操作</p><hr></li><li><p><u>挂载到节点上的初始化方法</u>通常用 mounted 去操作，主动调起的用 methods 里面封装的方法</p></li><li><p><u>数据初始化</u>一般放到<code>created</code>里面，这样可以及早发请求获取数据</p><hr></li><li><p>如果有依赖 dom 必须存在的情况，就放到<code>mounted</code>里</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul><h3 id="_09-如何重新执行-created-钩子函数" tabindex="-1">09. 如何重新执行 created 钩子函数？ <a class="header-anchor" href="#_09-如何重新执行-created-钩子函数" aria-label="Permalink to &quot;09. 如何重新执行 created 钩子函数？&quot;">​</a></h3><ul><li>通过切换<code>v-if</code>的状态，组件会重新经历销毁、加载的过程</li></ul><h3 id="_10-嵌套组件的生命周期" tabindex="-1">10.嵌套组件的生命周期 <a class="header-anchor" href="#_10-嵌套组件的生命周期" aria-label="Permalink to &quot;10.嵌套组件的生命周期&quot;">​</a></h3><h4 id="_1-挂载阶段顺序" tabindex="-1">（1）挂载阶段顺序 <a class="header-anchor" href="#_1-挂载阶段顺序" aria-label="Permalink to &quot;（1）挂载阶段顺序&quot;">​</a></h4><ul><li><code>Father.beforeCreate</code></li><li><code>Father.created</code></li><li><code>Father.beforeMount</code></li><li><code>Son.beforeCreate</code></li><li><code>Son.created</code></li><li><code>Son.beforeMount</code></li><li><code>Son.mounted</code></li><li><code>Father.mounted</code></li></ul><h4 id="_2-更新阶段顺序" tabindex="-1">（2）更新阶段顺序 <a class="header-anchor" href="#_2-更新阶段顺序" aria-label="Permalink to &quot;（2）更新阶段顺序&quot;">​</a></h4><ul><li><code>Father.beforeUpdate</code></li><li><code>Son.beforeUpdate</code></li><li><code>Son.updated</code></li><li><code>Father.updated</code></li></ul><h4 id="_3-异步组件挂载顺序" tabindex="-1">（3）异步组件挂载顺序 <a class="header-anchor" href="#_3-异步组件挂载顺序" aria-label="Permalink to &quot;（3）异步组件挂载顺序&quot;">​</a></h4><ul><li><code>Father.beforeCreate</code></li><li><code>Father.created</code></li><li><code>Father.beforeMount</code></li><li><code>Father.mounted</code></li><li><code>Father.beforeUpdate</code></li><li><code>Son.beforeCreate</code></li><li><code>Son.created</code></li><li><code>Son.beforeMount</code></li><li><code>Son.mounted</code></li><li><code>Father.updated</code></li></ul>`,39),d=[l];function r(n,s,c,h,u,p){return o(),a("div",null,d)}const m=e(i,[["render",r]]);export{_ as __pageData,m as default};
