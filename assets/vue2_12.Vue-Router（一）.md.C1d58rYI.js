import{_ as a,D as i,c as r,j as l,I as o,w as s,a as t,a3 as n,o as d}from"./chunks/framework.BkEKdGEG.js";const Z=JSON.parse('{"title":"","description":"","frontmatter":{"created":"2023-08-28T00:00:00.000Z","updated":"2023-08-28T00:00:00.000Z"},"headers":[],"relativePath":"vue2/12.Vue-Router（一）.md","filePath":"vue2/12.Vue-Router（一）.md","lastUpdated":1716610678000}'),h={name:"vue2/12.Vue-Router（一）.md"},u=n('<h2 id="_01-基本概念" tabindex="-1">01. 基本概念 <a class="header-anchor" href="#_01-基本概念" aria-label="Permalink to &quot;01. 基本概念&quot;">​</a></h2><h3 id="_1-基础概念" tabindex="-1">（1）基础概念 <a class="header-anchor" href="#_1-基础概念" aria-label="Permalink to &quot;（1）基础概念&quot;">​</a></h3><ul><li><code>Vue-router</code>：即 SPA（单页应用）的路径管理器，</li><li>根据不同的用户 URL 请求，返回不同的内容</li><li><code>vue-router</code>是 Vue 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用 <ul><li><code>vue</code>的单页面应用是基于路由和组件的 <ul><li>路由用于设定访问路径，并<strong>将路径和组件映射</strong></li></ul></li></ul></li></ul><h3 id="_2-对比" tabindex="-1">（2）对比 <a class="header-anchor" href="#_2-对比" aria-label="Permalink to &quot;（2）对比&quot;">​</a></h3><ul><li>传统页面应用，是用一些<strong>超链接</strong>来实现页面切换和跳转的</li><li>单页面应用中，则是<strong>路径之间的切换，也就是组件的切换</strong></li></ul><h3 id="_3-本质" tabindex="-1">（3）本质 <a class="header-anchor" href="#_3-本质" aria-label="Permalink to &quot;（3）本质&quot;">​</a></h3><ul><li>路由模块的本质：就是<strong>建立起<code>url</code>和组件之间的一一映射关系</strong></li></ul><h2 id="_02-实现原理" tabindex="-1">02. 实现原理 <a class="header-anchor" href="#_02-实现原理" aria-label="Permalink to &quot;02. 实现原理&quot;">​</a></h2><h3 id="_1-原理" tabindex="-1">（1）原理 <a class="header-anchor" href="#_1-原理" aria-label="Permalink to &quot;（1）原理&quot;">​</a></h3>',9),c=l("li",null,[l("p",null,[l("code",null,"SPA(single page application)"),t("：单一页面应用程序，只有一个完整的页面")]),l("ul",null,[l("li",null,"它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容"),l("li",null,"单页面应用的核心之一是：更新视图而不重新请求页面")])],-1),_=l("p",null,[l("code",null,"vue-router"),t("在实现单页面前端路由时，提供了两种方式：")],-1),p=n(`<blockquote><p>根据<code>mode</code>参数来决定采用哪一种方式</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果这里不写,路由默认为 hash模式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      routes: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote>`,1),g=l("h2",{id:"_03-两种模式",tabindex:"-1"},[t("03. 两种模式 "),l("a",{class:"header-anchor",href:"#_03-两种模式","aria-label":'Permalink to "03. 两种模式"'},"​")],-1),k=l("h3",{id:"_1-hash-模式",tabindex:"-1"},[t("（1）Hash 模式 "),l("a",{class:"header-anchor",href:"#_1-hash-模式","aria-label":'Permalink to "（1）Hash 模式"'},"​")],-1),b=l("code",null,"vue-router",-1),y=l("li",null,[l("p",null,"实现原理："),l("ul",null,[l("li",null,"使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载"),l("li",null,[l("code",null,"onhashchange"),t(" 事件：通过这个事件来监测 hash 值的变化，从而更新页面的部分内容")])])],-1),f=l("p",null,"工作方式：",-1),R=l("code",null,"#",-1),m=l("code",null,"#",-1),x=l("strong",null,"滚动到相应位置",-1),E=l("ul",null,[l("li",null,[t("同时，每一次改变"),l("code",null,"#"),t("后的部分，都会在浏览器的"),l("strong",null,"访问历史中"),t("增加一个记录")]),l("li",null,"使用浏览器的【后退】按钮，就可以回到上一个位置")],-1),q=l("strong",null,"不会被包含在 Http 请求中",-1),L=l("code",null,"#",-1),U=l("ul",null,[l("li",null,"因此，对后端来说，即使没有做到对路由全覆盖，也不会返回 404 错误，且改变 hash 不会重新加载页面")],-1),A=l("li",null,[l("p",null,"最后总结："),l("ul",null,[l("li",null,[t("Hash 模式就是通过"),l("strong",null,"锚点值的改变"),t("，根据不同的值，渲染指定 DOM 位置的不同数据")])])],-1),H=l("h3",{id:"_2-history-模式",tabindex:"-1"},[t("（2）History 模式 "),l("a",{class:"header-anchor",href:"#_2-history-模式","aria-label":'Permalink to "（2）History 模式"'},"​")],-1),P=l("blockquote",null,[l("ul",null,[l("li",null,[l("p",null,[t("由于 hash 模式会在 URL 地址中自带"),l("code",null,"#"),t("，这样 URL 地址看上去就不是那么美观")])]),l("li",null,[l("p",null,[t("如果不想要很丑的 hash "),l("code",null,"#"),t("符号，我们可以使用 history 模式")])])])],-1),T=n("<li><p>模式配置：只需要在配置路由规则时，加入<code>mode: &#39;history&#39;</code></p></li><li><p>实现原理：</p><ul><li>利用了 HTML5 中新增的两个 API—— <code>pushState()</code>、 <code>replaceState()</code></li><li>这两个方法应用于浏览器记录栈，在当前已有的 <code>back</code>、<code>forward</code>、<code>go</code> 基础之上，它们提供了对历史记录修改的功能</li><li>通过这两个 API ，可以改变 URL 地址且不会发送请求，不需要重新加载页面</li></ul></li>",2),S=l("p",null,"工作方式：",-1),v=l("a",{href:"http://xxx.com/user/id%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%A4%9A%E4%BD%99%E7%9A%84%60#%60%E7%AC%A6%E5%8F%B7",target:"_blank",rel:"noreferrer"},"http://xxx.com/user/id，没有多余的`#`符号",-1),C=l("code",null,"# ",-1),V=l("ul",null,[l("li",null,"这个实现需要服务器的支持")],-1),D=l("ul",null,[l("li",null,"因此， 在 URL 匹配不到任何静态资源时，应该返回同一个页面（如首页）")],-1),F=l("li",null,[l("p",null,"最后总结："),l("ul",null,[l("li",null,[t("History 模式就是通过"),l("code",null,"pushState()"),t("方法来对浏览器的浏览记录进行修改，来达到不用请求后端来渲染的效果")])])],-1),I=n('<h3 id="_3-比较" tabindex="-1">（3）比较 <a class="header-anchor" href="#_3-比较" aria-label="Permalink to &quot;（3）比较&quot;">​</a></h3><ul><li><p><strong>History 模式</strong>设置新的 URL 可以是与当前 URL <strong>同源的任意 URL</strong></p></li><li><p><strong>Hash 模式</strong>只可修改 <code>#</code> 后面的部分，因此只能设置与当前 URL <strong>同文档的 URL</strong></p><hr></li><li><p><strong>History 模式</strong>设置的新 URL 可以与当前 URL <strong>一模一样</strong>，这样也会把记录添加到栈中</p></li><li><p><strong>Hash 模式</strong>设置的新值必须与原来<strong>不一样</strong>才会触发操作并将记录添加到栈中</p><hr></li><li><p><strong>History 模式</strong>通过<code>stateObject</code> 参数可以添加<strong>任意类型</strong>的数据到记录中</p></li><li><p><strong>Hash 模式</strong>只能添加<strong>短字符串</strong></p><hr></li><li><p><strong>History 模式</strong>的前端 URL 必须与后端 URL 一致，否则后端无法处理，将<strong>返回 404 错误</strong></p></li><li><p><strong>Hash 模式</strong>即使后端没有路由，也<strong>不会返回 404 错误</strong></p><hr></li><li><p><strong>History 模式</strong>可以设置额外的<code>title</code>属性供后续使用</p></li></ul><table><thead><tr><th style="text-align:left;">History 模式</th><th style="text-align:left;">Hash 模式</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>History 模式</strong>设置新的 URL 可以是与当前 URL <strong>同源的任意 URL</strong></td><td style="text-align:left;"><strong>Hash 模式</strong>只可修改 <code>#</code> 后面的部分，因此只能设置与当前 URL <strong>同文档的 URL</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>设置的新 URL 可以与当前 URL <strong>一模一样</strong>，这样也会把记录添加到栈中</td><td style="text-align:left;"><strong>Hash 模式</strong>设置的新值必须与原来<strong>不一样</strong>才会触发操作并将记录添加到栈中</td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>通过<code>stateObject</code> 参数可以添加<strong>任意类型</strong>的数据到记录中</td><td style="text-align:left;"><strong>Hash 模式</strong>只能添加<strong>短字符串</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>的前端 URL 必须与后端 URL 一致，否则后端无法处理，将<strong>返回 404 错误</strong></td><td style="text-align:left;"><strong>Hash 模式</strong>即使后端没有路由，也<strong>不会返回 404 错误</strong></td></tr><tr><td style="text-align:left;"><strong>History 模式</strong>可以设置额外的<code>title</code>属性供后续使用</td><td style="text-align:left;">---</td></tr></tbody></table><blockquote><p>注：还有一种<code>abstract</code>模式，它支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></blockquote><h2 id="_04-页面跳转" tabindex="-1">04. 页面跳转 <a class="header-anchor" href="#_04-页面跳转" aria-label="Permalink to &quot;04. 页面跳转&quot;">​</a></h2><h3 id="_1-修改地址栏" tabindex="-1">（1）修改地址栏 <a class="header-anchor" href="#_1-修改地址栏" aria-label="Permalink to &quot;（1）修改地址栏&quot;">​</a></h3><ul><li>直接修改地址栏进行跳转</li></ul><h3 id="_2-编程式导航" tabindex="-1">（2）编程式导航 <a class="header-anchor" href="#_2-编程式导航" aria-label="Permalink to &quot;（2）编程式导航&quot;">​</a></h3><ul><li><p>通过调用 JavaScript 形式的 API 实现</p><ul><li><p><code>this.$router.push(‘路由地址’)</code></p><blockquote><p>会向<code>history</code>栈添加一个记录，可通过浏览器后退按钮回退</p></blockquote></li><li><p><code>this.$router.replace()</code></p><blockquote><p>会替换掉当前<code>history</code>记录，不会向<code>history</code>添加记录</p></blockquote></li><li><p><code>this.$router.go(n)</code></p><blockquote><p>用<code>n</code>表示在<code>history</code>记录中前进/后退多少步，类似于方法<code>window.history.go(n)</code></p></blockquote></li></ul></li></ul><h3 id="_3-声明式导航" tabindex="-1">（3）声明式导航 <a class="header-anchor" href="#_3-声明式导航" aria-label="Permalink to &quot;（3）声明式导航&quot;">​</a></h3><ul><li>通过点击链接实现： <code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></li></ul>',11);function B(N,j,w,$,O,J){const e=i("font");return d(),r("div",null,[u,l("ul",null,[c,l("li",null,[_,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("Hash 模式")]),_:1}),t("和"),o(e,{color:"blue"},{default:s(()=>[t("History 模式")]),_:1})])]),p])]),g,k,l("ul",null,[l("li",null,[l("p",null,[t("模式配置："),b,t(" 默认 "),o(e,{color:"red"},{default:s(()=>[t("hash 模式 ")]),_:1})])]),y,l("li",null,[f,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（1）")]),_:1}),t("hash 即 URL 中的"),R,t("符号，也称为锚点，代表的是网页中的一个位置")]),l("li",null,[o(e,{color:"blue"},{default:s(()=>[t("（2）")]),_:1}),t("hash 的改变，即改变"),m,t("后的部分，浏览器只会"),x,t("，不会重新加载网页"),E]),l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（3）")]),_:1}),t("hash 出现在 URL 中，但"),q,t("，仅有"),L,t("符号之前的内容会被包含在请求中"),U])])]),A]),H,P,l("ul",null,[T,l("li",null,[S,l("ul",null,[l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（1）")]),_:1}),t("当你使用 history 模式时，URL 正常显示，例如 "),v]),l("li",null,[o(e,{color:"blue"},{default:s(()=>[t("（2）")]),_:1}),t("但因为没有 "),C,t("号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求"),V]),l("li",null,[o(e,{color:"red"},{default:s(()=>[t("（3）")]),_:1}),t("而且由于在发送请求时，前端的 URL 必须和实际请求 URL 一致，否则将返回 404 错误"),D])])]),F]),I])}const z=a(h,[["render",B]]);export{Z as __pageData,z as default};
