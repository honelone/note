import{_ as e,c as o,o as l,a1 as i}from"./chunks/framework.yskgK-vV.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Other/Webpack/06.Webpack若干问题.md","filePath":"Other/Webpack/06.Webpack若干问题.md"}'),a={name:"Other/Webpack/06.Webpack若干问题.md"},r=i('<h2 id="webpack-若干问题" tabindex="-1">Webpack 若干问题 <a class="header-anchor" href="#webpack-若干问题" aria-label="Permalink to &quot;Webpack 若干问题&quot;">​</a></h2><h3 id="_01-webpack-是什么" tabindex="-1">01. Webpack 是什么？ <a class="header-anchor" href="#_01-webpack-是什么" aria-label="Permalink to &quot;01. Webpack 是什么？&quot;">​</a></h3><ul><li><code>webpack</code>是一种前端资源构建工具，一个静态模块打包器 <ul><li><strong>前端资源构建工具</strong>：就是把浏览器不认识的一些资源，通过一些处理构建，让这些资源能够正常工作在浏览器中</li><li><strong>静态模块打包器</strong>：就是把开发过程中的各种资源文件，通过引用关系，构建一个依赖图，并打包成一个或多个<code>bundle</code>输出</li></ul></li></ul><hr><h3 id="_02-为什么需要-webpack" tabindex="-1">02. 为什么需要 Webpack？ <a class="header-anchor" href="#_02-为什么需要-webpack" aria-label="Permalink to &quot;02. 为什么需要 Webpack？&quot;">​</a></h3><ul><li>使用<code>webpack</code>可以解决很多问题，比如： <ul><li>代码更改后的热更新问题</li><li>高级语法的不兼容问题</li><li>跨域问题</li><li>图片压缩问题</li></ul></li></ul><h3 id="_03-webpack-的构建流程是什么" tabindex="-1">03. Webpack 的构建流程是什么？ <a class="header-anchor" href="#_03-webpack-的构建流程是什么" aria-label="Permalink to &quot;03. Webpack 的构建流程是什么？&quot;">​</a></h3><ul><li><p><strong>初始化参数</strong>：解析<code>webpack</code>配置参数</p><ul><li>合并<code>shell</code>命令传入的参数，和<code>webpack.config.js</code>文件配置的参数，统一形成最后的配置结果</li></ul></li><li><p><strong>开始编译</strong>：初始化<code>Compiler</code>对象</p><ul><li>用上一步得到的参数初始化<code>Compiler</code>参数</li><li>注册所有配置的插件。插件会监听<code>webpack</code>构建声明周期的事件节点，并做出相应的反应</li><li>执行对象的<code>run</code>方法开始执行编译</li></ul></li><li><p><strong>确定入口</strong>：找到所有入口文件</p><ul><li>根据配置的<code>entry</code>参数找到所有入口文件</li><li>开始解析文件构建<code>AST</code>语法树，找出依赖，递归下去</li></ul></li><li><p><strong>编译模块</strong>：编译所有依赖的模块</p><ul><li>从入口文件出发，调用所有配置的<code>Loader</code>对模块进行翻译</li><li>再找出该模块的依赖模块，递归本步骤，直到所有依赖文件都经过处理</li></ul></li><li><p><strong>完成模块编译</strong>：得到所有模块内容</p><ul><li>经上一步<code>Loader</code>编译后，可以得到每个模块被翻译后的最终内容，以及它们之间的依赖关系</li></ul></li><li><p><strong>输出资源</strong>：组装代码块<code>Chunk</code>文件</p><ul><li>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的<code>Chunk</code></li><li>再把每个<code>Chunk</code>转换成一个单独的文件，并加入到输出列表中</li></ul></li><li><p><strong>输出完成</strong>：输出文件到系统</p><ul><li>确定好输出内容后，会根据配置确定的输出路径和输出文件名，将<code>Chunk</code>写入文件系统中</li></ul></li></ul><hr><h3 id="_04-常见的-plugin-有哪些" tabindex="-1">04. 常见的 Plugin 有哪些？ <a class="header-anchor" href="#_04-常见的-plugin-有哪些" aria-label="Permalink to &quot;04. 常见的 Plugin 有哪些？&quot;">​</a></h3><ul><li><strong>html-webpack-plugin</strong>：根据模板自动生成<code>HTML</code>代码，并自动引入<code>CSS</code>和<code>JS</code>文件</li><li><strong>web-webpack-plugin</strong>：更方便的为单页应用输出 HTML</li><li><strong>mini-css-extract-plugin</strong>：将<code>JS</code>文件中引用的样式单独抽离成<code>CSS</code>文件</li><li><strong>define-plugin</strong>：在编译时配置全局变量</li><li><strong>HotModuleReplacementPlugin</strong>：热更新</li><li><strong>optimize-css-assets-webpack-plugin</strong>：对不同组件中重复的 CSS 可以快速去重</li><li><strong>webpack-bundle-analyzer</strong>：打包结果分析工具</li><li><strong>compression-webpack-plugin</strong>：使用<code>gzip</code>压缩 JS 和 CSS 文件</li><li><strong>clean-webpack-plugin</strong>：清理每次打包输出目录下的文件</li><li><strong>speed-measure-webpack-plugin</strong>：可以看到整个打包过程，和每个<code>Loader</code>和<code>Plugin</code>执行耗时</li><li><strong>terser-webpack-plugin</strong>：支持压缩 ES6 代码</li></ul><hr><h3 id="_05-常见的-loader-有哪些" tabindex="-1">05. 常见的 Loader 有哪些？ <a class="header-anchor" href="#_05-常见的-loader-有哪些" aria-label="Permalink to &quot;05. 常见的 Loader 有哪些？&quot;">​</a></h3><ul><li><strong>file-loader</strong>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li><strong>url-loader</strong>：和<code>file-loader</code>类似，但是能在文件很小的情况下以<code>base64</code>的方式把文件内容注入到代码中</li><li><strong>source-map-loader</strong>：加载额外的<code>Source Map</code>文件，以方便断点调试</li><li><strong>image-loader</strong>：加载并压缩图片文件</li><li><strong>svg-inline-lader</strong>：将雅俗胡的 SVG 内容注入到代码里</li><li><strong>babel-loader</strong>：把 ES6 代码转换为 ES5 代码</li><li><strong>ts-loader</strong>：将 TS 代码转换成 JS 代码</li><li><strong>awesome-typescript-loader</strong>：将 TS 代码转换成 JS 代码，性能比<code>ts-loader</code>好</li><li><strong>css-loader</strong>：处理 CSS 文件</li><li><strong>style-loader</strong>：把 CSS 代码注入到 JS 代码中，通过 DOM 操作去加载 CSS</li><li><strong>postcss-loader</strong>：扩展 CSS 语法，使用下一代 CSS，配合<code>autoprefixer</code>可自动不起 CSS3 前缀</li><li><strong>eslint-loader</strong>：通过<code>ESLint</code>检查 JS 代码</li><li><strong>vue-loader</strong>：加载 Vue 单文件</li></ul><hr><h3 id="_06-loader-和-plugin-的区别" tabindex="-1">06. Loader 和 Plugin 的区别？ <a class="header-anchor" href="#_06-loader-和-plugin-的区别" aria-label="Permalink to &quot;06. Loader 和 Plugin 的区别？&quot;">​</a></h3><ul><li><p><strong>Loader</strong>本质上就是一个函数，在该函数中对接收到的内容进行转换，并返回转换后的结果</p><ul><li>因为<code>webpack</code>只认识<code>Javascript</code>，所以<code>Loader</code>就是将其它类型资源进行转换的预处理工作</li></ul></li><li><p><strong>Plugin</strong>就是插件，基于事件流框架<code>Tapable</code>，用于扩展<code>webpack</code>的功能</p><ul><li>在<code>webpack</code>运行的生命周期中，会广播出许多事件</li><li><code>Plugin</code>可以监听这些事件，并在合适的时机通过<code>webpack</code>提供的 API 改变输出结果</li></ul></li><li><p><strong>Loader</strong>在<code>module.rules</code>中配置，作为模块的解析规则，类型为数组。</p><ul><li>每一项都是一个<code>Object</code>，内部包含了<code>test</code>、<code>loader</code>、<code>options</code>等属性</li></ul></li><li><p><strong>Plugin</strong>在<code>plugins</code>中单独配置，类型为数组，每一项都是一个<code>Plugin</code>的实例，参数都通过构造函数传入</p></li></ul><hr><h3 id="_07-plugin-的实现原理" tabindex="-1">07. Plugin 的实现原理 <a class="header-anchor" href="#_07-plugin-的实现原理" aria-label="Permalink to &quot;07. Plugin 的实现原理&quot;">​</a></h3><ul><li><code>Webpack</code>本质上是一个 事件流机制，主要的核心模块是： <ul><li><code>compiler</code>暴露了和<code>webpack</code>整个生命周期相关的钩子</li><li><code>compilation</code>暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定<code>apply</code>方法才能访问<code>compiler</code>实例</li><li>传给每个插件的<code>compiler</code>对象和<code>compilatin</code>对象都是同一个引用</li></ul></li></ul><hr><h3 id="_08-loader-的实现原理" tabindex="-1">08. Loader 的实现原理 <a class="header-anchor" href="#_08-loader-的实现原理" aria-label="Permalink to &quot;08. Loader 的实现原理&quot;">​</a></h3><ul><li>每个<code>Loader</code>只负责处理一个事件</li></ul><hr><h3 id="_09-webpack-性能优化" tabindex="-1">09. Webpack 性能优化 <a class="header-anchor" href="#_09-webpack-性能优化" aria-label="Permalink to &quot;09. Webpack 性能优化&quot;">​</a></h3><ul><li><strong>代码压缩</strong>：删除多余的代码、注释，简化代码的写法</li><li><strong>CDN 分发</strong>：将引用的静态资源包修改为 CDN 上对应的路径</li><li><strong>Tree Shaking</strong>：将代码中永远不会需要的片段删除掉</li><li><strong>Code Splitting</strong>：将代码按路由维度或者组件分块（<code>Chunk</code>）</li><li><strong>提取公共第三方库</strong>：抽取公共模块</li></ul>',26),c=[r];function d(t,n,s,g,p,u){return l(),o("div",null,c)}const k=e(a,[["render",d]]);export{h as __pageData,k as default};
